# make predictions in pure Python

import math

# hard-coded weights for the neural network
first_layer_weights = [[-0.47743892669677734, -0.21491459012031555, 0.42652207612991333, 0.1707860231399536, 0.5776270031929016, 0.2934889793395996, 0.10986220836639404, -0.070223867893219, 0.2384810447692871, 0.02168452739715576, -0.160047709941864, -0.10356411337852478], [-0.37010443210601807, -0.5089291334152222, -0.43219873309135437, -0.44717928767204285, -0.2301860749721527, 0.6872920393943787, -0.5057080984115601, -0.4843493103981018, -0.07415753602981567, -0.4614729881286621, -0.39642009139060974, -0.21860508620738983], [-0.5397568345069885, 0.09295928478240967, 1.3579471111297607, 1.1323906183242798, 0.9759626984596252, -0.8116480112075806, -0.28817686438560486, 0.07773399353027344, -0.09671759605407715, 0.5452925562858582, -0.29479318857192993, 0.40835264325141907], [0.38573193550109863, -0.1033284068107605, 1.1268662214279175, 0.5659093260765076, 0.9082695245742798, -0.3379160165786743, -0.3598281443119049, 0.021406829357147217, -0.507798969745636, -0.5061297416687012, 0.4323497414588928, 0.8166036009788513]]
first_layer_biases = [0.0, 0.0, -0.2375214695930481, 0.15066483616828918, -0.3365461826324463, 0.5500139594078064, 0.0, 0.0, 0.0, 0.0, 0.0, -0.5240817070007324]
second_layer_weights = [[0.3075783848762512, 0.0017592906951904297, 0.282160222530365, 0.532192587852478, 0.38919055461883545, -0.08558177947998047, -0.3265945017337799, 0.054222047328948975], [0.016333580017089844, 0.05156368017196655, -0.05658188462257385, 0.44999241828918457, 0.12776917219161987, -0.21071752905845642, -0.09703871607780457, 0.21432721614837646], [0.03938911482691765, 0.07794857025146484, 1.1574301719665527, -0.18156522512435913, 0.21066899597644806, 0.10977590084075928, 0.7265502214431763, 0.694148600101471], [-0.03721843659877777, -0.1998104751110077, 0.8081619143486023, -0.33468112349510193, 0.1310274451971054, -0.560794472694397, 1.1219757795333862, -0.08525963127613068], [-0.026006074622273445, -0.13867568969726562, 0.9958667755126953, -0.3509436845779419, 0.5602887272834778, -0.07963630557060242, 0.7862027287483215, 0.5185465216636658], [-0.4623669683933258, -0.4033057689666748, -0.9831586480140686, -0.07476329803466797, -0.6378215551376343, 0.20443157851696014, -0.5818244218826294, -1.5998908281326294], [-0.39535677433013916, -0.4640396535396576, 0.041033923625946045, 0.17958760261535645, -0.30322933197021484, -0.05585503578186035, 0.08442580699920654, 0.26592421531677246], [0.015922129154205322, -0.10065090656280518, -0.4882242977619171, -0.41168487071990967, -0.12238100171089172, 0.193267822265625, -0.4495725631713867, 0.18472778797149658], [-0.12487730383872986, 0.3501814603805542, -0.5127391815185547, -0.23096716403961182, -0.10410350561141968, 0.0509987473487854, -0.17315998673439026, 0.437031090259552], [0.26578640937805176, 0.2763282060623169, 0.244301438331604, 0.1670951247215271, 0.44465988874435425, -0.49867570400238037, 0.4432898759841919, -0.35946932435035706], [0.18827807903289795, -0.005254149436950684, -0.19630318880081177, 0.29554033279418945, 0.20434027910232544, -0.15623065829277039, 0.362746000289917, 0.21800130605697632], [0.22678661346435547, -0.536490261554718, 1.3962597846984863, 0.012502789497375488, 2.150804281234741, 0.38936105370521545, -2.4066405296325684, 2.2834951877593994]]
second_layer_biases = [-0.07650886476039886, 0.0, -0.3194118142127991, 0.0, -0.6889436841011047, -0.20052814483642578, 0.2437058985233307, -0.7016584277153015]
output_layer_weights = [[0.6283605694770813, 0.7129018306732178, -0.5738214254379272], [0.46264714002609253, 0.5316022038459778, -0.49803149700164795], [-1.4799736738204956, 0.10447096079587936, 0.5546830892562866], [-0.7097349166870117, 0.6270727515220642, -0.6887797117233276], [-1.0136830806732178, -1.791588306427002, 1.5328266620635986], [-0.14666354656219482, 0.6818621754646301, 0.580498456954956], [-1.364971399307251, 0.9770811796188354, -0.9992315173149109], [-0.11923744529485703, -1.9477548599243164, 1.9388229846954346]]
output_layer_biases = [1.3694753646850586, -0.7420641183853149, -1.4657484292984009]

# load data

INPUT_COUNT = 4   # input vector size
OUTPUT_COUNT = 3   # output vector size

def load_data(filename):
    fs = open(filename, "r").read().split('\n')
    fs = [line.split(',') for line in fs]
    input_matrix = []
    output_matrix = []
    for i in range(len(fs)):
        input_data = [float(t) for t in fs[i][:INPUT_COUNT]]
        output_data = [float(fs[i][INPUT_COUNT][j] == '1') for j in range(OUTPUT_COUNT)]
        input_matrix.append(input_data[:])
        output_matrix.append(output_data[:])
    return (input_matrix, output_matrix)

training_input, training_output = load_data("iris_training.dat")
validation_input, validation_output = load_data("iris_validation.dat")
testing_input, testing_output = load_data("iris_testing.dat")


# classification

def relu(x):
    return max(x, 0)

def classify(input0):
    layer1 = []
    for i in range(12):
        s = first_layer_biases[i]
        for j in range(4):
            s += first_layer_weights[j][i] * input0[j]
        layer1.append(relu(s))
    layer2 = []
    for i in range(8):
        s = second_layer_biases[i]
        for j in range(12):
            s += second_layer_weights[j][i] * layer1[j]
        layer2.append(relu(s))
    output = []
    for i in range(3):
        s = output_layer_biases[i]
        for j in range(8):
            s += output_layer_weights[j][i] * layer2[j]
        output.append(s)
    return output

def output_to_class(output):
    maxi = -1
    maxval = float("-inf")
    for i in range(len(output)):
        if output[i]>maxval:
            maxi, maxval = i, output[i]
    return maxi


# test accuracy

def test_accuracy(input, output):
    N = len(input)
    correct_count = 0
    for i in range(N):
        expected = output_to_class(output[i])
        predicted = output_to_class(classify(input[i]))
        if expected == predicted:
            correct_count += 1
    print(f"{correct_count}/{N} ({correct_count/N})")

test_accuracy(training_input, training_output)
test_accuracy(validation_input, validation_output)
test_accuracy(testing_input, testing_output)
