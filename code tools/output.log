D:\Coding\Github\Git Notes.txt
Line ending: \r\n
L1	Switch to default branch: git checkout master
L2	Add file/directory: git add <file/directory>
L3	Add all tracked and untracked files: git add --all
L4	Recursively delete folder: git rm -r <folder-name>
L5	List all files: git ls-files
L6	Commit change: git commit -m "<change-name>"
L7	Push to remote repository: git push origin master

D:\Coding\Github\DMOJ Render_Main\Render_Main\pch.cpp
Ignored

D:\Coding\Github\DMOJ Render_Main\Render_Main\Render_Main.cpp
Line ending: \r\n
L1	// To-do:
L2	// Fit to polynomial;
L3	// Turn to learning Eigens
L29	//fitFourierSeries(v, 40, a, b, true, true);
L32	//fitPolynomial_Parametric(v, 50, c, true, true);
L39	//#define main Main
L43	//int main() {
L46	//    return 0;

D:\Coding\Github\DMOJ Render_Main\Render_Main\DMOJ-Render_Main\geometry.h
Line ending: \r\n
L1	// Implement vector/matrix data types - source might not be very readable
L32	// not standard
L34	// not standard
L38	// not standard
L52	// added when needed
L82	// non-standard
L124	// cubic spline class - put it there for some reason
L149	// range
L151	// cubic polynomial in [0,1]
L190	// intersection - return shortest positive distance
L191	// text intersection for bounding box before calling this function when performance matters
L194	// cubic equation coefficients
L198	// test if a root is valid
L202	// requires rd to be normalized
L209	// degenerated case
L224	// cubic solver - may have room for optimization
L229	// one real root
L234	// three real roots
L254	// not actually all geometry functions, just some numerical methods
L261	// numerical integration, T can be scalar/vector/matrix
L275	// solve a linear system (no handling for degenerated case)
L290	// random number
L291	// override C++ libraries, use it after including C++ libraries to avoid compile error
L294	// 32bit unsigned integer
L295	// uniformly between 0 and 1, inclusive
L297	// inverse error function
L303	// normal-distributed random number
L307	// random unit vector

D:\Coding\Github\DMOJ Render_Main\Render_Main\DMOJ-Render_Main\rasterize.h
Line ending: \r\n
L1	// rasterization of svgs, mostly for debug
L12	// debug output
L40	// "render" it as a svg path - the original shape will be modified
L49	// border
L50	// nodes
L51	// shape
L59	// a sketchy rasterizer
L66	// abgr
L96	// origin: top-left; x-axis: right; y-axis: down
L125	// render path to image
L128	// the shape will be modified with transform is set to true
L143	// debug
L155	// render Fourier series to image
L162	// use for adaptive step
L183	// helps with rapid curvature change

D:\Coding\Github\DMOJ Render_Main\Render_Main\DMOJ-Render_Main\README.md
Line ending: \r\n
L3	Whoever sees the code in this repository will be severely cursed. **CURIOSITY KILLED THE CAT.**

D:\Coding\Github\DMOJ Render_Main\Render_Main\DMOJ-Render_Main\svg.cpp
Line ending: \r\n
L1	// Data of DMOJ logo and related operations
L16	// modified
L18	// this one is for debug
L27	// an old code that splits a svg path into cubic arcs
L120	// doable using least square fitting but the code can be pretty messy
L133	// an old code that converts a svg shape to a C++ string
L171	// copy-pasted from an online integral calculator
L172	// use Green's formula - note the conditions are important
L183	// center of mass
L195	// calculate the line-based center of mass (hollow shape)
L196	// requires numerical integration
L211	// bounding box
L222	// intersection
L234	// operations
L246	// useful in converting screen and image coordinates
L251	// Implement rotation and reverse direction when needed

D:\Coding\Github\DMOJ Render_Main\Render_Main\DMOJ-Render_Main\1pointer\acc4p0.cpp
L1	"All Kill"

D:\Coding\Github\DMOJ Render_Main\Render_Main\DMOJ-Render_Main\1pointer\acc4p7.cpp
Line ending: \r\n
L3	"Bulbasaur"
L3	"Ivysaur"
L3	"Venusaur"
L3	"Charmander"
L3	"Charmeleon"
L3	"Charizard"
L3	"Squirtle"
L3	"Wartortle"
L3	"Blastoise"
L3	"Caterpie"
L4	"Metapod"
L4	"Butterfree"
L4	"Weedle"
L4	"Kakuna"
L4	"Beedrill"
L4	"Pidgey"
L4	"Pidgeotto"
L4	"Pidgeot"
L4	"Rattata"
L4	"Raticate"
L5	"Spearow"
L5	"Fearow"
L5	"Ekans"
L5	"Arbok"
L5	"Pikachu"
L5	"Raichu"
L5	"Sandshrew"
L5	"Sandslash"
L5	"Nidorina"
L6	"Nidoqueen"
L6	"Nidorino"
L6	"Nidoking"
L6	"Clefairy"
L6	"Clefable"
L6	"Vulpix"
L6	"Ninetales"
L6	"Jigglypuff"
L6	"Wigglytuff"
L7	"Zubat"
L7	"Golbat"
L7	"Oddish"
L7	"Gloom"
L7	"Vileplume"
L7	"Paras"
L7	"Parasect"
L7	"Venonat"
L7	"Venomoth"
L7	"Diglett"
L8	"Dugtrio"
L8	"Meowth"
L8	"Persian"
L8	"Psyduck"
L8	"Golduck"
L8	"Mankey"
L8	"Primeape"
L8	"Growlithe"
L8	"Arcanine"
L8	"Poliwag"
L9	"Poliwhirl"
L9	"Poliwrath"
L9	"Kadabra"
L9	"Alakazam"
L9	"Machop"
L9	"Machoke"
L9	"Machamp"
L9	"Bellsprout"
L9	"Weepinbell"
L10	"Victreebel"
L10	"Tentacool"
L10	"Tentacruel"
L10	"Geodude"
L10	"Graveler"
L10	"Golem"
L10	"Ponyta"
L10	"Rapidash"
L10	"Slowpoke"
L10	"Slowbro"
L11	"Magnemite"
L11	"Magneton"
L11	"Doduo"
L11	"Dodrio"
L11	"Dewgong"
L11	"Grimer"
L11	"Shellder"
L12	"Cloyster"
L12	"Gastly"
L12	"Haunter"
L12	"Gengar"
L12	"Drowzee"
L12	"Hypno"
L12	"Krabby"
L12	"Kingler"
L12	"Voltorb"
L13	"Electrode"
L13	"Exeggcute"
L13	"Exeggutor"
L13	"Cubone"
L13	"Marowak"
L13	"Hitmonlee"
L13	"Hitmonchan"
L13	"Lickitung"
L13	"Koffing"
L13	"Weezing"
L14	"Rhyhorn"
L14	"Rhydon"
L14	"Chansey"
L14	"Tangela"
L14	"Kangaskhan"
L14	"Horsea"
L14	"Seadra"
L14	"Goldeen"
L14	"Seaking"
L14	"Staryu"
L15	"Starmie"
L15	"Mr. Mime"
L15	"Scyther"
L15	"Electabuzz"
L15	"Magmar"
L15	"Pinsir"
L15	"Tauros"
L15	"Magikarp"
L15	"Gyarados"
L16	"Lapras"
L16	"Ditto"
L16	"Eevee"
L16	"Vaporeon"
L16	"Jolteon"
L16	"Flareon"
L16	"Porygon"
L16	"Omanyte"
L16	"Omastar"
L16	"Kabuto"
L17	"Kabutops"
L17	"Aerodactyl"
L17	"Snorlax"
L17	"Articuno"
L17	"Zapdos"
L17	"Moltres"
L17	"Dratini"
L17	"Dragonair"
L17	"Dragonite"
L17	"Mewtwo"

D:\Coding\Github\DMOJ Render_Main\Render_Main\DMOJ-Render_Main\1pointer\cccjqrp3.cpp
Line ending: \r\n

D:\Coding\Github\DMOJ Render_Main\Render_Main\DMOJ-Render_Main\1pointer\helloworldhard.py
Line ending: \r\n
L1	"Hello, World!"
L2	"Hello, World!"
L3	"Hello, World!"

D:\Coding\Github\DMOJ Render_Main\Render_Main\DMOJ-Render_Main\1pointer\miraclesort.c
Line ending: \r\n

D:\Coding\Github\DMOJ Render_Main\Render_Main\DMOJ-Render_Main\1pointer\piggy.py
L1	'Moana'

D:\Coding\Github\DMOJ Render_Main\Render_Main\DMOJ-Render_Main\1pointer\piggy.txt

D:\Coding\Github\DMOJ Render_Main\Render_Main\DMOJ-Render_Main\1pointer\README.md
Line ending: \r\n
L3	## Unofficial explanations for DMOJ “meme” problems:
L7	The first line is ended with a `\n`, the second line is ended with a `\r`, and the third line is ended with `\r\n`.
L11	There is only one test case, where ~N=1521~. The inputs followed can be decimal digits, lowercase English words, lowercase French words, or Simplified Chinese characters.
L23	Output the numbers in the input order will make you pass.
L27	`AK` stands for `All Kill`.
L31	The function to implement is to return `true` if ~n~ is happy. The definition of happy numbers can be found at https://en.wikipedia.org/wiki/Happy_number.
L35	If your submission gets partial AC, the grader's feedback will be `(amaze!!1)`. Submitting it in Text will likely make you pass.
L37	Other full-point short Text submissions include `print('Moana')`, `Unicode`, `:Xyene`, `12`, `KFC`, `youtube`, etc.
L41	There is no input for this problem. Seems like any non-empty output can pass.
L49	All inputs can fit into 64-bit unsigned integer. Your task is to output ~A+B+C~, modulo ~42069900169420~.
L53	Read the problem statement carefully. It tells you to output the integers from ~1~ to ~N~.
L57	One can see from existing comments that these characters are not allowed in code: `"'1234567890`.
L63	This problem asks you to recognize digits from bitmap images. The first line of input contains an integer, ~N~, the number of test images. Followed by ~28N~ lines, each line contains ~28~ real numbers between ~0~ and ~1~, representing ~N~ ~28\times28~ bitmap images, where each image contain a decimal digit. Your program should output ~N~ lines. In each line, output the digit in the image.
L65	The image represented in the sample input can be found in [this comment](https://dmoj.ca/problem/tle18p1#comment-12374).
L67	This problem contains 10 test cases. In all test cases, ~N=1000~. If your program has a proper output, you will receive feedback for the accuracy of your algorithm.
L69	The maximum point for this problem is 512. One guesses the point is calculated as ~\lfloor2^{\lfloor20(a-0.5)\rfloor}\rfloor~, where ~a~ is the minimum accuracy of all test cases.
L73	The input for this problem is a lowercase English letter. When the input is `a`, the answer is `a`. Otherwise, the answer is the answer to the previous letter of the input letter in the English alphabet plus the input letter plus the answer to the previous letter in the English alphabet.
L75	For example, when the input is `b`, your output should be `a`+`b`+`a`=`aba`. When the input is `c`, your output should be `aba`+`c`+`aba`=`abacaba`.
L77	If the instruction count of your code is greater than or equal to 1000, only 3/4 of points will be given. The grader may return WA even though the output matches.
L81	The picture in the problem is in SVG format (where all other problem pictures in that contest are PNG). This SVG contains base64-encoded PNG images stacked up, in which the picture contents include doors, ghost faces, emojis, photos, codes, etc. All `<image>` objects have an `id` attribute. It also contains an empty `<defs>`, a `<metadata>`, and an invisible `<g>`.
L83	There is a base64-encoded image string with a `\n` line break every 76 characters, and all other images use space instead. The content of that image is an instruction to `Write f:`. Other pictures with code include a screenshot of Sample Input 1 of [this problem](https://dmoj.ca/problem/ccc19s3) and an image that looks like a clipped Brain\*\*\*\* code. The order of the pictures may have some meaning.
L85	As this problem worths 40 points, solving it *may* require some coding skills more than understanding the intention of the problem. This problem has AC submissions in Text and C++, as well as Text TLE submissions.
L89	If your program tries to request, it crashes.
L91	If your program outputs `the following file`, the grader's feedback will be `Nice try, print the actual file`.
L93	To fail solutions that use data compression, the grader is updated to detect non-ASCII characters.
L95	Notice problem statement:
L97	> a hardware token that he has locally... uniformly at random within the range configured...
L98	> Your score will be inversely correlated to the length of your program...
L99	> To ensure you have the correct output...
L117	## Pages that list esoteric problems:
L134	## Additional note:
L136	The DMOJ admins have banned user "[Tomorrow](https://dmoj.ca/user/Tomorrow)" from editing profile and posting comments. This page is currently available for updates.

D:\Coding\Github\DMOJ Render_Main\Render_Main\DMOJ-Render_Main\1pointer\saoj.py
Line ending: \r\n
L1	# Reference solution
L2	# This problem can be fun for optimization/golfing

D:\Coding\Github\DMOJ Render_Main\Render_Main\DMOJ-Render_Main\1pointer\scroll.txt

D:\Coding\Github\DMOJ Render_Main\Render_Main\DMOJ-Render_Main\1pointer\thereturnofaplusb.cpp
Line ending: \r\n

D:\Coding\Github\DMOJ Render_Main\Render_Main\DMOJ-Render_Main\1pointer\tle18p6.svg
Line ending: \n

D:\Coding\Github\DMOJ Render_Main\Render_Main\DMOJ-Render_Main\fit\Fit.h
Line ending: \r\n
L1	// Fitting template
L2	// Make sure to include "svg.cpp" before including this header
L12	// Fit point set to polynomial, c[k] has degree k
L16	// calculate sums and powers
L17	// the sums can be replaced by integral
L27	// setup linear equations
L38	// solve the linear system
L41	// output
L47	// polynomial evaluation

D:\Coding\Github\DMOJ Render_Main\Render_Main\DMOJ-Render_Main\fit\polynomial.cpp
Line ending: \r\n
L1	// Fit a path consisting of splines to a single-variable polynomial
L29	// print_reverse: reflect at x-axis
L51	// works bad
L56	// similar to the trigonometric one
L75	// the coefficients can be extremly large or small
L93	// least square fitting, almost a copy-paste of the one in Fit.h
L97	// Indefinite integral of xⁿsin(kx)
L115	// setup linear equations
L126	// solve the linear system
L129	// output

D:\Coding\Github\DMOJ Render_Main\Render_Main\DMOJ-Render_Main\fit\trigonometric.cpp
Line ending: \r\n
L1	// Fit a path consisting of splines to trigonometric series
L8	// continuous Fourier series, 0 < t < 2π
L30	// if print_reverse is true, this output will be reflected at x-axis to fit graphing calculators
L50	// [slow] angle-based Fourier series - let P be the origin, fit r(θ)
L62	// test shows accuracy mostly depend on min_dif and performance mostly depend on dif
L65	//const int dif = 200;
L76	"Time Elapsed: %lfms\n"

D:\Coding\Github\DMOJ Render_Main\Render_Main\DMOJ-Render_Main\Render_Main\dmoj01.cpp
Line ending: \n

D:\Coding\Github\DMOJ Render_Main\Render_Main\DMOJ-Render_Main\Render_Main\rgb01.cpp
Line ending: \n

D:\Coding\Github\Graphics\fitting\#edge_detector.cpp
Line ending: \r\n
L8	// image format library, https://github.com/nothings/stb
L324	// pictures/illustrations/photos/sketchs, found on the internet
L338	"Error "

D:\Coding\Github\Graphics\fitting\#implicit2bezier.cpp
Line ending: \r\n
L1	"Ofast"
L49	//============================ Basic Definitions ============================//
L117	//===================== Cubic Spline Class and Operations =====================//
L150	//======================== Fitting Implicit Functions ========================//
L153	// any single-connected continuous function
L157	//return x3 * (x - 2) + y3 * (y - 2);  // triangular teeth
L158	//return x4 + y4 - x2 - y2 - x - y;  // another triangular teeth
L159	// teeth, incisor
L161	//return pow(x2 + y2 - y, 2) - (x2 + y2);  // Descartes's heart
L166	// numerical gradient and curvature of the function
L188	// find a point on implicit curve using Newton's iteration method
L211	// draw a spline
L253	// visualize implicit function, with axis
L267	"\aOpen File Failed!\n\n"
L276	// visualize list of splines
L293	"\aOpen File Failed!\n\n"
L306	// Simpson's method may not work well for cubic and higher degree functions
L332	// assume P and Q are on the implicit surface and u and v are normalized
L360	"Error = %lf\n"
L365	// core function

D:\Coding\Github\Graphics\fitting\Circle Fitting.cpp
Line ending: \r\n
L1	// Fitting a circle to point set experiment
L14	// ============================================================== Fitting ==============================================================
L17	// Fit points to a circle with center C and radius r
L19	// circle equations:
L36	// After a heavy simplification, this problem turns into solving a linear system
L51	// Minimize the same equation numerically
L52	// Test the numerical optimizer
L61	// The function to minimize
L62	// count call times
L71	// I believe this will become a quadratic form after simplification
L75	//printf("%d\n", Calls);  // this varies from 20+ to 150+; Newton_Iteration_2d only 9x3=27 (theoretically 9 or 18)
L79	// Minimize Σ[x²+y²+ax+by+c]² and determine C and R from a,b,c
L80	// Result is exactly the same as the previous functions
L106	// Visually, this works better than the above methods (but much slower)
L110	// Warn that this function sometimes does not contain a local minima
L125	// start from the result of the previous function
L126	// this significantly reduces the chance of failure
L129	// faster but less stable
L130	// do not have to calculate R because it is already calculated
L132	// debug output
L137	// Same as previous except it uses analytical gradients, more than 3 times faster
L140	// calculating the analytical gradient of this function is truly a nightmare......
L164	// calculate R
L168	// debug output
L171	// In the test, this function fails 6 cases in 10000 cases.
L172	// All failures are caused by the gradient information leading it to infinity.
L173	// Try to detect failure and restart iteration from a new startpoint when fails.
L178	// This formula gives a better estimate of the Euclidean distance
L198	// [green] Same formula with some analytical simplifications
L215	// just too lazy to calculate the analytical derivative of this
L228	// Surprisingly, this one doesn't work better than the previous one (and is more unstable)
L251	// ============================================================== Visualizing ==============================================================
L254	// visualizing fitting results
L255	// contains graphing classes/variables/functions
L262	// color structs
L270	// image variables
L278	// graphing functions - code for simplicity not performance
L311	// initialize and save image
L321	// ============================================================== Testing ==============================================================
L329	// generate point data in the pattern of a circle
L331	// parameters of the line
L334	// parameters of random number generator
L337	// generating random points
L345	// write lots of pictures to see fitting results
L349	// generate point data
L353	// fitting and visualization
L356	// minimize algebraic distance, should be identical
L360	// minimize Euclidean distance
L362	// minimize approximated Euclidean distance
L366	// visualization
L369	// save image
L377	// test the performance and stability of numerical methods
L379	// write to file
L380	// on my system this directly writes to console if this line is commented
L384	// the same generator as randomTest_image
L389	// fitting
L401	// (possible) failure
L406	"%lfsecs elapsed\n"

D:\Coding\Github\Graphics\fitting\color fitting.cpp
Line ending: \r\n
L16	// Regression, it is not recommand for N > 8
L79	// cubic interpolation
L123	"Find a RGB coloring function based on a bitmap image.\nImage decoder from http://nothings.org/stb, support most common image formats.\n\n"
L132	"Select Image: "
L140	"Error loading image. Press Enter to exit.\n"
L160	//return 0;
L162	"Loading image succeed. ("

D:\Coding\Github\Graphics\fitting\Ellipse Fitting.cpp
Line ending: \r\n
L1	// Fitting ellipse to planar point set experiment
L5	/* To-do:
     - handle the case when the matrix is not invertible
     - try to render dashed/dotted lines because the colors are really messy
     - think this problem: do fitted shapes change after translating the points?
*/
L11	// Ironically, in this file, testing code is longer than fitting code.
L15	// some modules are organized into the "numerical" folder
L32	// Ellipse fitting - v contains the coefficients of { x², xy, y², x, y, 1 }, {a,b,c,d,e,f}
L34	// generate least square fitting matrix, should be positive (semi)definite
L48	// Ellipse fitting with quadratic constraints, solve for eigenvalues
L50	// Minimize vᵀMv, subject to vᵀv=1
L54	// if not ellipse, check other eigenvalues
L68	// Minimize vᵀMv, subject to vᵀCv=1
L69	// To get expected result, C should be non-negative definite
L70	// I'm sure there is a bug because it sometimes gets hyperbolas
L74	// B is not symmetric
L77	// make sure it is an ellipse
L92	// Minimize vᵀMv, subject to 4ac-b²=1
L97	// Minimize vᵀMv, subject to a²+c²=1
L108	// Minimize vᵀMv/vᵀCv, where C is the sum of magnitude of gradients
L109	// doesn't "shrink", visually good but checking hyperbolas makes it horrible
L123	// Ellipse fitting with linear constraints, solve a linear system
L125	// Minimize vᵀMv, subject to a+c=1
L155	// Minimize vᵀMv, subject to f=1
L188	// Fitting quadratic curves by minimizing the sum of the square of the exact Euclidean distance
L189	// As a reference, doesn't seem to be practical
L191	// calculate the exact distance to a quadratic curve (slow)
L195	// temp variables
L199	// coefficients of the quartic equation
L205	// solve for the Lagrangian
L208	// curve not exist
L209	// not sure if this can work
L210	// continuous but not differentiable
L217	// find the nearest root
L227	// "refine" the root
L232	// Ellipse fitting using the Euclidean distance
L234	// hope this curve doesn't go through the origin...
L262	// ================================================================ Testing Code ================================================================
L266	// visualizing ellipse fitting results
L267	// contains graphing classes/variables/functions
L274	// color structs
L283	// image variables
L293	// painting functions
L296	// go through all pixels (may be slow)
L322	// initialize a value buffer
L328	// map the value of the buffer to the image
L330	// calculate numerical gradient from neighbourhood values
L333	// magnitude of gradient
L334	// divide by gradient to estimate distance
L340	// visualizing distance function
L352	// initialize and save image
L367	// Test fitting methods with random data
L369	// test eigenvalue calculation
L413	"%lfs elapsed\n"
L416	// generate point data in the pattern of an ellipse
L418	// parameters of the ellipse
L429	// parameters of random number generator
L433	// generating random points
L436	// using iteration to make points close to the ellipse
L443	// add noise
L448	// use random data to test ellipse fitting methods
L453	// generate point data
L457	// fitting
L466	// write result to stdout
L476	// visualization
L478	// visualize fitting result
L481	// reference; one should be able to identify failures visually (#97 is pretty obvious)
L482	// v² : light green
L483	// 4ac-b² : khaki color
L484	// a²+c² :  orange
L486	// v²/grad² : purple
L487	// a+c : hollow blue
L488	// f : hollow pink
L500	// save image
L509	// test the performance and stability of ellipse fitting methods
L513	// generate test data
L520	// fitting
L524	// place an ellipse fitting function there
L528	// check result
L550	// test if shape change after linear transforms
L665	// All methods except fitEllipse0 can get hyperbolas.
L666	// Among these methods, fitEllipse_grad works visually best.

D:\Coding\Github\Graphics\fitting\Line Fitting.cpp
Line ending: \r\n
L1	// Fitting a straight to point set experiment
L3	// To-do:
L14	// ============================================================== Fitting ==============================================================
L17	// Fit points to a straight line ax+by+c=0
L20	// standard linear regression
L32	// orthogonal distance least square fitting
L33	// results of the two methods should represent the same line
L35	// derived using equation of straight line cos(t)x+sin(t)y-d=0
L50	// derived using Lagrange multiplier
L67	// ============================================================== Visualizing ==============================================================
L70	// visualizing fitting results
L71	// contains graphing classes/variables/functions
L78	// color structs
L86	// image variables
L94	// graphing functions - code for simplicity not performance
L126	// initialize and save image
L140	// ============================================================== Testing ==============================================================
L143	// generate point data in the pattern of a straight line
L145	// parameters of the line
L149	// parameters of random number generator
L152	// generating random points
L160	// write lots of pictures to see fitting results
L163	// generate point data
L167	// fitting
L171	// visualization
L178	// save image

D:\Coding\Github\Graphics\implicit\quadtree.cpp
Line ending: \r\n
L1	// Graphing Implicit Surface
L4	/* ==================== User Instructions ====================

 *  Move View:                  drag background
 *  Zoom:                       mouse scroll, hold shift to lock center
 */
L12	// ========================================= Win32 Standard =========================================
L14	// some compressed copy-paste code
L21	"Spline Tester"
L27	// implement the following functions:
L73	// debug
L79	// ================================== GLSL Style Classes/Functions ==================================
L99	// not standard but useful
L101	// not standard
L105	// not standard
L119	// not standard
L126	// ======================================== Data / Parameters ========================================
L133	// window parameters
L134	// window title
L135	// origin in screen coordinate
L136	// screen unit to object unit
L140	// user parameters
L208	//return x * x + y * y - 1;
L209	//return hypot(x, y) - 1;
L211	//return x * x*x*x + y * y*y*y + x * y;
L212	//return y - sin(5*x);
L213	//return abs(x) - abs(y);
L214	//return abs(x*y) - 1;
L215	//return sin(x) + sin(y);
L216	//return hypot(x, y)*cos(hypot(x, y)) - x;
L217	//return 1 / x - x / y;
L218	//return sin(x + y * y) + y * y*exp(x + y) + 5 * cos(x*x + y);
L226	// ============================================ Rendering ============================================
L317	// line may "break" in this situation
L354	// I believe there's bug but it's hard to debug
L363	// debug
L369	// initialize window
L372	// "pixel shader" graphing implicit curve
L384	// axis and grid
L387	// adaptive grid color
L388	// horizontal gridlines
L389	// vertical gridlines
L390	// x-axis
L391	// y-axis
L407	// ============================================== User ==============================================
L429	// click and drag

D:\Coding\Github\Graphics\light2d\light2d (intersector).cpp
Line ending: \r\n
L1	"Ofast"

D:\Coding\Github\Graphics\light2d\light2d (no recursion).cpp
Line ending: \r\n
L20	// not standard
L24	// not standard
L73	//return length(p) - 1.0;    // circle
L78	// cross
L80	// letter H
L155	// log to Visual Studio output window
L207	"secs elapsed. ("
L208	"secs elapsed. ("

D:\Coding\Github\Graphics\light2d\light2d (path).cpp
Line ending: \r\n
L1	"Ofast"
L36	//============================ Basic Definitions ============================//
L94	// 2x3 matrix, linear transform
L116	//===================== Cubic Spline Class and Operations =====================//
L177	// unit arc from angle 0 to theta, 0 < theta < pi, least square fitting
L219	// visualization for debugging
L264	// avoid special cases in calculating intersections
L278	// construct a ray toward right, return the number of intersections
L333	// Green's formula, doens't work when two regions have intersections
L400	//============== Conversion between SVG Path Data and Spline Lists ==============//
L504	// probably have bugs
L584	//============================== Debug Test Cases ==============================//
L609	"House"
L609	"Heart"
L609	"Cloud"
L609	"IE Logo"
L609	"Flower"
L609	"Windows"
L609	"Sector"
L609	"Shield"
L609	"Shell"
L609	"Sigma"
L614	//================================= Rendering =================================//
L651	"\aOpen File Failed!\n\n"
L815	"\aOpen File Failed!\n\n"

D:\Coding\Github\Graphics\light2d\light2d.cpp
Line ending: \r\n
L1	"Ofast"
L25	// Signature, BM
L28	// File Size
L29	// reserved
L30	// Full header size, usually 54 byte
L31	// DIB header size, 40 byte
L32	// width
L33	// height
L34	// planes, always 1
L35	// bits per pixel
L36	// compression
L37	// Image Size
L38	// X pixels per meter
L39	// Y pixels per meter
L47	// Pad row size to a multiple of 4
L127	//return length(p) - 1.0;    // circle
L132	// cross
L134	// letter H
L182	//double a = rand();    // uniform
L183	//double a = 2.0 * PI * double(i) / SAMPLE;    // stratified
L184	// jittered
L186	//c += traceRay(p, d, 0);    // without anti-aliasing
L187	// anti-aliasing may fail if the light is too bright
L240	"secs elapsed. ("

D:\Coding\Github\Graphics\light2d\light3d (debug).cpp
Line ending: \r\n
L21	// non-standard
L25	// non-standard
L36	// non-standard
L38	// non-standard
L79	// Camera
L80	// camera ray origin
L81	// camera ray center direction, modulus represents distance to screen
L82	// screen scaling, where 1 means the width and height of the screen forms an unit vector
L87	// fog, 1-exp(-d) chance of scattering per unit distance
L128	// rx and ry are uniform sampled random numbers between 0 and 1
L134	// random direction
L212	// log to Visual Studio output window
L276	"secs elapsed. ("
L277	"secs elapsed. ("

D:\Coding\Github\Graphics\light2d\svg path.cpp
Line ending: \r\n
L1	"Ofast"
L63	// 2x3 matrix, linear transform
L107	// unit arc from angle 0 to theta, 0 < theta < pi, least square fitting
L108	// recommend theta < 2
L140	// debugging code
L184	// core function
L286	// probably have bugs
L337	// S0 test cases: from https://bezier.method.ac/
L350	// S1 test cases: Adobe Illustrator Export
L359	// S2 test cases: Targeted Testing, some from the internet
L370	// 1.15M large file
L383	"Succeed"
L387	"Succeed"
L390	// stucks on S2[9]
L391	"Succeed"
L396	"  Elapsed Time: %lfsecs.\n"

D:\Coding\Github\Graphics\light2d\light2d tests (path)\xlog_01.txt
Line ending: \r\n
L1	House
L8	Heart
L29	Cloud
L64	IE Logo
L71	Flower
L99	Windows
L106	Sector
L113	Shield
L120	Shell
L127	Sigma
L141	Press any key to continue . . .

D:\Coding\Github\Graphics\numerical\eigensystem.h
Line ending: \r\n
L1	// organized from "Ellipse Fitting.cpp"
L2	// assume all matrices are positive definite
L4	// To-do: implement more eigenvalue algorithms
L25	// checks the correctness of eigenpair calculation
L26	// eigvec should be normalized
L32	"Error! [eigensystem.h %d] %lg\n"
L36	"Error! [eigensystem.h %d] %lg\n"
L56	// find the all eigenpairs of a matrix by solving its characteristic equation
L57	// eigvec: a matrix of row vectors
L58	// due to the O(N⁴) complexity and error accumulation in Gaussian elimination, it is not recommend for N>6
L63	// avoid overflow/precision error
L72	// expand characteristic polynomial, works in O(n^4)
L73	// method discribed at https://mathworld.wolfram.com/CharacteristicPolynomial.html
L87	// find the roots of the characteristic polynomial
L90	// Newton's iteration method starting at x=0
L91	// this should success because the matrix is positive definite
L104	// "refine" the root using the original polynomial
L116	// divide the root from the polynomial
L120	// export the eigenvalue
L123	// find the eigenvector from the eigenvalue
L143	// idk why this happens
L158	// try to "refine" the eigenvector using some iterative methods
L160	// export normalized eigenvector
L175	// find an eigenpair using power iteration and inverse iteration
L180	// use power of matrix to make it converge faster
L181	// sometimes the numbers can get extremely large and cause precision/overflow error
L193	// power iteration
L207	// warning: float-point precision
L209	// calculate eigenvalue from eigenvector
L230	// zero off-diagonal elements of a symmetric matrix using given rotation matrices
L231	// eigvec is an orthogonal matrix of row eigenvectors
L232	// keep result eigenvalues and eigenvectors as diagonalized form (unsorted)
L242	// calculate the rotation matrix
L244	// idk why this makes it 1.4x faster on my machine
L247	// apply inverse rotation to the left side of A
L253	// apply rotation to the right side of A
L259	// apply rotation to the right side of C

D:\Coding\Github\Graphics\numerical\geometry.h
Line ending: \r\n
L14	// for macros, do not use rand() because it will be called multiple times
L25	// test: faster in debug mode but not release mode
L43	// a sketchy planar vector template
L92	// a more sketchy 3d vector template
L103	// element wise
L131	// diagonal matrix
L135	// diagonal matrix
L139	// symmetric matrix
L143	// matrix by column vectors
L146	// ordered in row-wise
L161	// sum of square of elements
L178	// mostly used for debug output

D:\Coding\Github\Graphics\numerical\interpolation.h
Line ending: \r\n
L6	// linear interpolation
L13	// cubic interpolation by derivative
L19	// slerp, second derivative, Bezier, B, Hermite, Catmull-Rom, Lagrange, bicubic, rational, trigonometric, fitting...

D:\Coding\Github\Graphics\numerical\linearsystem.h
Line ending: \r\n
L1	// seems like hard-coding matrices as static 2d arrays can be 1.2x faster
L2	// do dirty things when performance really matter
L14	// copy a matrix
L22	// matrix multiplication, C needs to be different from A B
L31	// matrix times vector, b needs to be different from x
L40	// evaluate uᵀAv
L49	// evaluate uᵀv
L56	// trace of a matrix
L63	// determinant of a matrix
L79	// matrix inversion
L99	// matrix transpose
L112	// solve linear system, assume the matrix is invertible and not too large
L133	// symmetric matrix only, initialize X to an initial guess
L134	// seems to be O(N^3) for non-sparse matrices; larger constant than elimination and higher error
L155	//if (i > maxIter) maxIter = i;
L164	// debug
L175	// M rows and N columns

D:\Coding\Github\Graphics\numerical\ode.h
Line ending: \r\n
L1	// dxdt: given vector and time, calculate the derivative
L2	//       void dxdt(const double* x, double t, double* dx_dt);
L3	// x: given vector at time t0, update it to time t1
L4	// N: length of vector
L5	// t0: start time
L6	// dt: last time (end time is t0+dt)
L7	// temp: initialize to size N, use to avoid memory allocation
L57	// To-do: implicit method; adaptive step length

D:\Coding\Github\Graphics\numerical\optimization.h
Line ending: \r\n
L2	// function minimization experiment
L3	// macro _DEBUG_OPTIMIZATION is defined in _debug_optimization_2d.cpp
L5	// To-do:
L6	// Bracket minimum in one dimension
L7	// Conjugate gradient
L8	// Downhill simplex
L9	// Simulated annealing
L18	// One-dimensional optimization
L19	// These functions receive parameters as reference instead of returning a number
L20	// because they are often used in multivariable optimizations and the functions may be expensive to evaluate.
L22	// before calling this function: evaluate y0=F(x0) and y1=F(x1) and make sure y1<y0
L23	/* Not Implemented */
L24	// minimize a 1d function where the minima is bracketed x0 and x1
L51	// numerical differentiation in 2d
L52	// not necessary when analytical gradient is given
L69	// Non-standard 2d methods based on Newton's iteration
L70	// Fails when iterates to a point with discontinuous or zero gradient
L73	// this method performs Newton's iteration in gradient direction
L82	// gradient
L83	// second derivative in gradient direction
L84	// simply taking an abs prevents it from reaching a maxima
L86	// break the balance when it reaches a saddle point (doesn't always work)
L87	// this makes it generally faster but more like to stuck on valleys
L92	// termination - small step, small difference, or nan
L108	// this method uses Newton-Raphson method to find a point with zero-gradient
L109	// it might be a local maxima, a minima, or a saddle point
L132	// this version doesn't get maxima and saddle but is slower
L133	// ideas of improvement include checking signs of eigenvalues and detecting infinite loops
L139	// numerical differentiation
L147	// solve the linear system
L150	// prevent reaching maxima
L152	// prevent reaching saddle
L153	// this may cause it to enter an infinite loop
L159	// termination
L175	// same function as Newton_Iteration_2d but uses analytical gradient, faster and more stable
L176	// F: double F(vec2 x, vec2 *grad, vec2 *grad2, double *dxy);
L183	// calculate Newton step
L186	// make sure it will reach a minimum
L187	// if not decent direction, go opposite
L188	// break the balance when it converges to a saddle point
L192	// test termination condition
L193	// Note that sometimes this terminates early due to coincidence
L208	// numerical differentiation in higher dimensions
L210	// F: double F(const double *x);
L211	// 2N samples
L226	// grad2: standard Hessian matrix
L227	// 2N²+1 samples - analytical derivative is highly recommend
L233	// gradient
L237	// second derivative
L239	// other derivatives
L257	// Optimization in higher dimensions
L262	// one iteration: O(N²) samples, O(N³) complexity; quadratic convergence
L263	// return true when (possible) succeed
L274	// make sure decent direction
L283	// test positive-definiteness (slow)
L289	// break the balance when it reaches a saddle point
L297	// termination

D:\Coding\Github\Graphics\numerical\random.h
Line ending: \r\n
L1	// define _RANDOM_H_BETTER_QUALITY before including this file for better random number quality
L15	// hash function
L22	// a hash function for GLSL; [-1,1] in C++
L27	// random number generators
L28	// use to generate float point random number
L32	// from Numerical Recipes
L39	// a better random number generator
L52	// float-point random number generators
L58	// approximation of inverse error function, use to generate normal distribution
L64	// uniform distribution in [a,b)
L65	// normal distribution by standard deviation
L66	// uniform pseudorandom integer in [a,b)
L67	// uniform distributed unit vector
L68	// default distribution in |v|<r
L69	// uniform distribution in |v|<r
L70	// normal distribution by standard deviation
L71	// uniform distributed unit vector
L72	// default distribution in |v|<r
L73	// uniform distribution in |v|<r
L74	// normal distribution by standard deviation
L75	// cosine-weighted random hemisphere
L84	// from Numerical Recipes, not accurate for small xm

D:\Coding\Github\Graphics\numerical\README.md
Line ending: \r\n
L1	Numerical algorithms used in computer graphics.
L3	Used by code in this repository. Add the `Graphics` folder to additional include directory in compiler settings.
L5	Avoid object orientation for simplicity and performance.
L7	Files started with an underscore are used to debug header files.
L11	[rootfinding.h](rootfinding.h): find the roots of functions;
L13	[optimization.h](optimization.h): find the minimum of functions; numerical differentiation;
L15	[geometry.h](geometry.h): 2d/3d vector, 3d matrix; misc macros/functions;
L17	[random.h](random.h): float-point random number generator;
L19	[linearsystem.h](linearsystem.h): matrixes as 1d arrays of length N×N; Gaussian elimination;
L21	[eigensystem.h](eigensystem.h): find the eigenvalues/eigenpairs of real symmetric matrices;
L23	[ode.h](ode.h): numerical ordinary differential equation solutions;
L25	To-do: integral.h, interpolation.h, fft.h, complex.h

D:\Coding\Github\Graphics\numerical\rootfinding.h
Line ending: \r\n
L1	// To-do:
L2	// General polynomial solver
L3	// Newton's iteration in one dimension
L4	// Multivariable numerical root-finding
L6	// Remove debug code in solveTrigPoly() after well-tested
L7	// Get rid of <algorithm> as it sometimes causes compile error when max and min macros are defined
L28	// These solvers may be accelerated a lot if manually write them inline and do simplifications according to the circumstance.
L29	// It is recommended to perform one Newton iteration for analytical solutions when accuracy is required.
L31	// In all functions: a multiple root is counted as multiple single roots
L35	// return 1: two or three real roots, r, u, v;
L36	// return 0: one real root r ~and two complex roots u+vi, u-vi~;
L42	// 1 root
L44	// u = cbrt(q + a)
L45	// v = cbrt(q - a)
L52	// 3 roots
L65	// Find all real roots of a quartic equation, return the number of real roots
L66	// R may not be already sorted
L77	// 2 roots
L79	// s = cbrt(r + h)
L80	// u = cbrt(r - h)
L93	// 4 or 0 roots
L110	// Use Newton's iteration once to reduce float-point inaccuracy
L126	// this one handles the case with zero higher coefficients
L128	// the numbers become extremely large when dividing by a small coefficient
L148	// Solve a*cos(x)+b*sin(x)+c=0 in non-degenerated case
L149	// solutions in [-π,π]; return false if no real solution
L170	// return the smallest root greater than x_min, NAN if not found
L171	// numerical solution, sometimes may miss roots; may be optimized further
L172	// standard quadratic solver
L185	// degenerated cases
L211	// split [0,2π] into 32 equal intervals
L215	// find the interval(s) with roots
L225	// check these intervals
L228	// search roots between t0 and t1
L234	// create a quadratic approximation of the trigonometric part
L241	// translate trigonometric polynomial and add k
L248	// solve the quadratic to get an approximation of the root
L252	// Newton iteration
L263	// check if the root is legal
L267	// this one should work
L286	// Ideas for small w:
L287	//  - Cubic instead of quartic approximation
L288	//  - See how quadratic approximation works out
L289	//  - Implement saperated quadratic, cubic, and quartic solvers
L290	//     - Should have no problem when passing zero k2 to quadratic solver
L291	//  - Don't use the substitution solution
L293	// return the first root greater than x_min; if not found, return NAN
L295	// original algorithm, may have better ways
L296	// substitude u = w*x+phi, x=(u-phi)/w
L309	// least-square fitted quartic polynomial for sine phases
L310	// splitting [0,2π] into 4 intervals with width π/2, and translate it to fit it to [0,π/2]
L311	// calculated in Python using 40 decimal places, should have no problem with double
L327	// find intervals that possibly have roots
L328	// find intervals that the absolute value of the polynomial is no more than m
L335	// polynomial is out of range
L336	// should never happen
L339	// check these intervals
L351	// search roots between t0 and t1
L359	// construct a quartic approximation of the function
L360	// translate the sine phase by t, and plus polynomial k
L373	// solve the quartic to get an approximation of the root
L378	// perform Newton's iteration
L385	// check if the root is legal
L388	// this one will work
L392	// substitude back
L398	// should not exceed 4
L403	// not found
L406	// designed to work for small w; without substitution
L407	// problem occurs when a small w encounters k4=0
L408	// test: 0.1x slower than solveTrigPoly()
L410	// the case when w=0
L423	// splitting [0,2π] into 8 intervals with width π/4 (a more accurate approximation, hope it works)
L434	// interval finding
L454	// search roots between t0 and t1
L462	// create a quartic approximation of the function using quartic approximations of sin and cos
L472	// translate trigonometric polynomial and add k
L482	// solve the quartic to get an approximation of the root
L486	// get the root
L494	// check if the root is legal
L497	// this one should work
L505	// should not exceed 8
L510	// not found
L514	// iter=1 should be enough; default value is 2

D:\Coding\Github\Graphics\numerical\_debug_eigensystem.cpp
Line ending: \r\n
L1	// Use to debug "eigensystem.h"
L3	// To-do: random matrix generator that generates non-invertible matrices
L30	// much more stable

D:\Coding\Github\Graphics\numerical\_debug_font_rendering.h
Ignored

D:\Coding\Github\Graphics\numerical\_debug_linearsystem.cpp
Line ending: \r\n
L1	// linear system solver test
L11	// standard derivation
L32	// large arrays as global variable
L37	// conjugate gradient should converge in no more than N iterations
L38	// but that number seems to be larger for large matrixes due to floatpoint truncation...
L90	"%lf secs\n"

D:\Coding\Github\Graphics\numerical\_debug_optimization.cpp
Line ending: \r\n
L6	// test numerical differentiation
L7	// this function helped me discovered and killed 3 bugs ;)
L9	// test function, one should be enough
L22	// Thank you, WolframAlpha!
L67	// test numerical differentiation in higher dimensions
L70	// not standard Rosenbrock function
L127	// test functions for optimization in arbitrary dimensions
L193	// one minima at xi=1; one maxima surrounded by a valley and one saddle point inside the valley
L210	// close to maxima/saddle

D:\Coding\Github\Graphics\numerical\_debug_optimization_2d.cpp
Line ending: \r\n
L2	// Use to test 2d function minimization methods in "optimization.h"
L3	// Comparing different optimization methods
L11	// visualization of optimization process and result
L18	// color structs
L26	// image variables
L35	// painting functions
L36	// this part is long and unrelated so I move function body to the end of this file
L43	// initialize and save image
L53	// ============================================================== Test Functions ==============================================================
L56	// optimization header
L61	// test functions for optimization
L62	// all functions contain at least one global minimas
L64	// test case id
L65	// function call count
L69	// contains 30 test functions
L74	// original cases
L90	// Rosenbrock function
L91	// Himmelblau's function
L92	// McCormick function (modified)
L93	// Beale function
L94	// Goldstein-Price function
L95	// Three-hump camel function
L96	// Styblinski-Tang function
L97	// Mishra's Bird function (modified unconstrained)
L98	// modified
L99	// Booth function
L120	// 5 test cases with analytical derivatives
L152	// (0,0,0) is a saddle point with zero first and second gradients
L168	// Case 5: Derived from a practical problem that **'d lots of optimizers
L169	// Code is exported by Wolfram Cloud Open Access
L177	// The original problem needs to minimize a function similar to the square root of above
L178	// That function might be the sum of many sqrts
L188	// ============================================================== Testing ==============================================================
L191	// test optimization algorithms in a visual way
L194	// iteration startpoints
L198	// initialize canvas
L236	// save rendered image
L249	// test optimization algorithms with analytical derivative
L262	// more clear
L280	// ============================================================== Visualization ==============================================================
L284	// go through all pixels (may be slow)
L309	// shade by distance to anti-alias
L312	// naive DDA, no anti-aliasing
L340	// initialize a value buffer
L350	// calculate numerical gradient from neighbourhood values
L355	// graph the zero-isoline of gradient
L368	// graph the contour
L372	// magnitude of gradient
L373	// divide by gradient to estimate distance
L375	// colors
L376	// interval mapping
L377	// linear interpolation
L381	// distance estimation has some artifacts at the points with high curvature
L382	// discontinuities may be stroked
L383	// zero-isoline stroke will be double-width when using logarithmic scale

D:\Coding\Github\Graphics\numerical\_debug_rootfinding.cpp
Line ending: \r\n
L5	// compile error with GCC
L18	// set up random numbers
L24	// solve equation
L38	// check
L58	// set up random numbers
L64	// solve equation
L76	// check
L96	// there is no guarantee that the solver does not miss a root or find an unintented root
L99	// set up random numbers
L109	// solve equation
L118	// check
L156	// bisection search
L166	// Newton's iteration
L214	"%d %d  %lf  %lf %lf  %lg\n"
L249	"%d %d  %lf  %lf %lf  %lg\n"

D:\Coding\Github\Graphics\numerical\tools\README.md
Line ending: \r\n
L1	Temporary tools used for writing scripts in the parent folder.
L3	As some scripts generate hard-coded data, they may be modified when the requirements changed.

D:\Coding\Github\Graphics\numerical\tools\sin_cos_2_poly.py
Line ending: \r\n
L1	# Python high precision numerical works
L2	# Still fails in degenerated cases (avoid it)
L4	# Fitting polynomial to trigonometric functions:
L5	# Given degree N, starting point a, ending point b, find the coefficients of polynomial of best fit
L64	# Gaussian elimination
L81	# Polynomials of best fit
L95	# Polynomials of best fit with boundary constrains
L116	# print polynomial coefficients for graphing calculators
L126	# print coefficients as C++ style initializer list
L136	# Print result; Split [0,2π] to N equal intervals and fit to quadratic function
L137	# N should be even
L139	# calculate coefficients
L142	# graphing calculator output
L148	# C++ initializer list output with shifting
L149	'const double C['

D:\Coding\Github\Graphics\numerical\tools\sin_cos_2_quartic.py
Line ending: \r\n
L1	# Approximate trigonometric functions using quartic polynomials
L2	# Find the coefficients of the quartic polynomial
L4	# Multivation:
L5	# Need to solve equations involving trigonometric functions
L6	# Quartic equations can be solved analytically
L7	# After finding the approximations of roots, perform Newton's iteration to find numerical solution
L9	# Arbitrary precision floating point
L13	# 100 decimal digits of π and √2
L17	# Analytical coefficients of polynomial of best fit in [0,pi/2]
L18	# Thanks Wolfram open access
L27	# lowest coefficient at first
L31	# Polynomial of best fit in [0,pi/4]
L44	# print coefficients as C++ style initializer list
L52	# print as polynomials for graphing calculators
L63	# translate a quartic polynomial right by d
L73	# reflect a polynomial about x axis
L77	# reflect a polynomial about y axis
L84	# Split [0,2π] into 4 and 8 intervals
L101	# Output for Desmos graphing calculator
L110	# Output for C++

D:\Coding\Github\Graphics\path\polygon.h
Line ending: \r\n
L17	// non-standard
L19	// non-standard
L23	// non-standard
L26	// square of distance to a line segment
L33	// test if segment a and b intersect each other
L39	// return the point of intersection
L53	// output polygon as svg path (usually for debug)
L66	// polygon vertex order
L77	// return false if already (counter)clockwise
L78	// for only testing cw and ccw, call calcArea()
L94	// force cw/ccw for polygons with self-intersection
L109	// geometric transformations
L129	// It should be guaranteed that the number of vertices of a polygon is at least 3.
L131	// # require no self-intersection
L132	// @ require convexity
L133	// $ general case (may not work in special case)
L137	// $ return true if the polygon is self-intersecting
L138	// brute force approach
L144	// $ return true if the polygon is convex
L145	// change all >0 to >=0 if this polygon is clockwise
L155	// $ test if a point is inside a polygon
L167	// return the perimeter of a polygon
L176	// # return the area of a polygon, negative when vertices ordered clockwise
L187	// return the average of all vertices
L194	// # return the center of mass
L204	// return the average of all edges
L218	// calculate the Axis-Aligned Bounding Box
L230	// calculate the Convex Hull
L235	// sort by x; if x equals, sort by y
L265	//void calcBoundingCircle(polygon P, vec2 &C, vec2 &R);
L275	// NAN, necessary for pathfinder functions
L284	// $ return false if no self-intersection found - runs in O(N²)
L286	// debug
L291	// $ cut a polygon, where dot(p-p0,n)>0 part is cut off
L297	// find a point that will not be cut off
L302	// the whole shape is cut off
L304	// trace segment
L307	// sometimes NAN
L324	// occurs when the line goes through a vertex
L327	// occurs when an edge lies on the line

D:\Coding\Github\Graphics\path\polygon_h_debug.cpp
Line ending: \r\n
L1	// debug this header file using Win32 GUI
L4	/* ==================== User Instructions ====================
 *  Print Polygon Data          ctrl + p, ctrl + s
 *  Move View:                  drag background
 *  Zoom:                       mouse scroll
 *  Move Polygon:               drag shape
 *  Rotate Polygon:             shift + drag
 *  Scale Polygon:              alt + drag
 *  Move Vertex:                click and drag
 *  Add Vertex:                 ctrl + click
 *  Delete Vertex:              right click
 *  Shift Vertex Order:         left / right
 *  Reverse Vertex Order:       space
 *  Hide/Unhide Vertices:       c
 *  Show/Hide Center:           m
 *  Show/Hide AABB:             b
 *  Show/Hide Convex Hull:      h
 */
L23	// ========================================= Win32 Standard =========================================
L25	// some compressed copy-and-paste code
L39	// image
L105	// debug
L112	// ======================================== Data / Parameters ========================================
L127	// window parameters
L128	// window title
L129	// origin in screen coordinate
L130	// screen unit to object unit
L134	// rendering parameters
L135	// rendering radius of control point
L136	// control points
L142	// user parameters
L152	// ============================================ Rendering ============================================
L174	// initialize window
L178	// rendering
L179	// dda
L217	// receives polygon in world coordinate
L225	// scan-line filling - I think it has a lot of room for optimization
L245	// stroke
L256	// grid and axis
L259	// adaptive grid color
L261	// horizontal gridlines
L263	// vertical gridlines
L264	// x-axis
L265	// y-axis
L268	// bounding boxes
L279	// polygons
L283	// center of polygons
L285	// edge center, orange
L286	// vertex center, purple
L287	// center of mass, green
L292	// control points
L307	// rendering completed
L319	// ============================================== User ==============================================
L325	// test performance
L357	// rotate shape
L361	// scale shape
L366	// drag control point
L370	// drag shape
L374	// drag grid
L381	// refresh distance to polygons
L393	// calculate fitted point
L424	// #1 drag: move a control point
L440	// #1 drag: move a control point
L443	// #2 Ctrl: add a control point
L460	// #3 right click: remove a control point
L484	// call MouseMove to calculate insert position
L501	// shift endpoint
L505	// shift endpoint
L509	// reverse point direction

D:\Coding\Github\Graphics\path\Spline Tester.cpp
Line ending: \r\n
L1	// Test Different Splines and Interpolation Methods
L2	// Incomplete, still updating
L5	/* ==================== User Instructions ====================

 *  Move View:                  drag background
 *  Zoom:                       mouse scroll, hold shift to lock center
 *  Move Point:                 click and drag
 *  Move Shape:                 alt + drag; shift + m
 *  Rotate Shape:               shift + drag
 *  Scale Shape:                S + drag
 *  Add Point:                  ctrl + click
 *  Delete Point:               right click
 *  Switch Endpoint:            left / right
 *  Reverse Point Direction:    space
 *  Center Points:              shift + c (only available in FourierSeries mode)
 *  Hide/Unhide Points:         c
 *  Next Method:                tab
 *  Last Method:                ctrl/shift + tab
 *  Show/Hide Trace:            b
 *  Lock/Unlock Trace:          l
 *  Trace Alpha:                ctrl + mouse scroll
 *  Save File (append):         ctrl + s
 */
L29	// ========================================= Win32 Standard =========================================
L31	// some compressed copy-paste code
L38	"Spline Tester"
L44	// implement the following functions:
L90	// debug
L96	// ================================== GLSL Style Classes/Functions ==================================
L116	// not standard but useful
L118	// not standard
L122	// not standard
L136	// not standard
L139	// by iq
L148	// ======================================== Data / Parameters ========================================
L153	// or fitting
L158	// number of supported interpolations
L161	"Linear Interpolation"
L161	"Centripetal Catmull-Rom Spline"
L162	"Quadratic B-Spline"
L162	"Standard Cubic B-Spline"
L163	"Quadratic Interpolation ###"
L163	"Cubic B-Spline Interpolation ###"
L164	"Fourier Series Fitting"
L173	// control points
L174	// selected (drag)
L175	// insert index
L177	// window parameters
L178	// window title
L179	// origin in screen coordinate
L180	// screen unit to object unit
L184	// rendering parameters
L185	// rendering radius of control point
L186	// control points
L187	// background image for trace
L189	// user parameters
L198	// image format library, https://github.com/nothings/stb
L203	// background image for tracing, where BKG has transparency
L206	// lower-left corner on screen coordinate
L207	// to screen coordinate
L208	// transparency
L210	// load background image from file
L220	// flip back: different image coordinates
L222	// rgb vs bgr
L241	// call this when alpha changed
L248	// get backgroud color from screen coordinate
L302	// uniform distribute parameter
L312	// return the average of all control points
L319	// put this at the end because they contain long string code
L324	// ============================================ Rendering ============================================
L343	// debug
L349	// initialize window
L355	// rendering
L393	// screen coordinate, C3 t³ + C2 t² + C1 t + C0
L403	// axis
L407	// control polygon
L413	// interpolation curve
L447	// control points
L452	// highlight insert position
L453	// the two larger points are startpoint
L457	// show the center of the figure
L473	// ============================================== User ==============================================
L499	// click and drag
L502	// control point
L515	// drag axis and grid
L521	// #2 Ctrl: add a control point
L559	// #1 drag: move a control point
L574	// #1 drag: move a control point
L582	// #2 Ctrl: add a control point
L598	// #3 right click: remove a control point
L611	// call MouseMove to calculate insert position
L642	// switch endpoint
L643	// switch endpoint
L644	// reverse point direction
L645	// previous/next interpolation method
L653	// ======================================== File Operations ========================================
L665	// encode binary data
L670	// just don't want "xx000000" to appear in text
L681	// write text expression
L684	// control points
L685	"// control points\n"
L690	// print Fourier coefficients
L695	// computed Fourier parameters
L696	"\n// computed Fourier parameters\n"
L704	// mathematical expression
L705	"\n// mathematical expression\n"
L734	// print svg path
L735	"\n// svg path\n"
L803	// security check

D:\Coding\Github\Graphics\path\svg path v.cpp
Line ending: \r\n
L12	//============================ Basic Definitions ============================//
L23	// non-standard
L25	// non-standard
L29	// non-standard
L30	// rotate 90deg counterclockwise
L34	// 2x3 matrix, linear transform
L54	// operator*(vec2): no translation
L55	// applyTo(vec2): have translation
L61	//===================== Cubic Spline Class and Operations =====================//
L121	// fitting, unit arc from angle 0 to a
L188	// based on Green's formula, doesn't work for unclosed, self-intersecting, and some multiple-connected shapes
L202	// copied from an online integral calculator and it's pretty unneat
L210	// line-based center of mass, works for unclosed and self-intersecting shapes
L242	//===================== Conversion between SVG Path and Spline Lists =====================//
L343	// possibly have bugs
L448	//================== Read SVG file - No error handling, valid svg please! ==================//
L457	// Vector Graphics
L468	// read tagname
L471	//cout << r.tagName << endl;
L472	// read attributes
L484	//cout << r.attributes.back().name << "      \t" << r.attributes.back().value << endl;
L489	// inline close element
L500	// close element
L505	// read subtree
L507	//cout << endl;
L509	//cout << endl;
L518	"clipPath"
L518	// remove it for some reason
L552	// not supported
L622	"clipPath"
L626	// read a svg file - no "defs" please!

D:\Coding\Github\Graphics\path\svg path.cpp
Line ending: \r\n
L1	"Ofast"
L37	//============================ Basic Definitions ============================//
L76	// 2x3 matrix, linear transform
L98	//===================== Cubic Spline Class and Operations =====================//
L159	// unit arc from angle 0 to theta, 0 < theta < pi, least square fitting
L202	// visualization for debugging
L245	// avoid special cases in calculating intersections
L259	// construct a ray toward right, return the number of intersections
L312	//===================== Conversion between SVG Path and Spline Lists =====================//
L415	// probably have bugs
L495	//===================== Debug Test Cases =====================//
L520	"House"
L520	"Heart"
L520	"Cloud"
L520	"IE Logo"
L520	"Flower"
L520	"Windows"
L520	"Sector"
L520	"Shield"
L520	"Shell"
L520	"Sigma"
L566	"\nTotal Time: %lfsecs.\n"

D:\Coding\Github\Graphics\path\svg tester.html
Line ending: \r\n
L3	SVG Path Tester
L44	transform = "
L64	// doesn't work
L70	// doesn't work

D:\Coding\Github\Graphics\raytracing\render_stl.cpp
Line ending: \r\n
L1	// Rasterization vs. Ray-Casting
L2	// Rasterization: mostly depends on the number of triangles
L3	// Ray-casting: mostly depends on the screen dimension (requires a O(nlogn) initialization)
L4	// In a 640x360 window, Ray-Casting wins when the # of triangles exceeds about 500,000
L5	// Ray-casting is much more memory-consuming than rasterization
L7	// To-do: Add kd-tree acceleration
L10	// debug
L18	// ========================================= Win32 Standard =========================================
L30	// debug
L37	// First Window (Main Window): UI Editor
L49	// only use this function to initialize variables (or test)
L67	// how you use this depends on you
L72	// Win32 Entry
L111	// ================================== Vector Classes/Functions ==================================
L115	//#define Inline inline
L117	//#define Inline __forceinline
L134	// not standard
L136	// not standard
L140	// not standard
L154	// added when needed
L182	// non-standard
L197	//Inline vec2& xy() { return *(vec2*)this; }
L216	// 4x4 matrix
L218	// first row, second row, third row
L219	// translation, perspective
L220	// scaling
L226	//return q * d;
L247	// All direction vectors should be normalized
L249	// Intersection functions - return the distance, NAN means no intersection
L250	// Warning: return value can be negative
L256	// requires d to be normalized
L261	// usually we want it to be positive
L307	// ray-tracing special
L312	// WARNING: performance
L317	// relative with precomputer normal cross(a,b)
L342	// ======================================== Data / Parameters ========================================
L344	// viewport
L345	// view center in world coordinate
L346	// yaw, pitch, row, camera distance, scale to screen
L350	// window parameters
L351	// window title
L352	// matrix
L353	// camera and screen
L356	// user parameters
L357	// current cursor and cursor position when mouse down
L359	// these variables are shared by both windows
L365	// projection
L377	// world translation
L378	// rotation
L379	// camera roll (ry)
L380	// perspective
L381	// scale
L382	// screen translation
L398	// these functions often need to handle perspective case
L404	// any space curve defined by C(t)=P+u*cos(t)+v*sin(t)
L435	// not sure if I use the right formula
L525	// center of mass and volume
L526	// Gauss formula, assume the triangles enclose the shape and the normals are outward
L555	// debug output, available when enable console
L571	// ============================================ Rendering ============================================
L627	// the slow way
L667	// debug
L698	// simply fill color, no normal calculation
L730	// n is already here so recalculation in the intersection function is unnecessary
L795	// brute-force rasterization
L805	// brute-force ray tracing
L818	// BVH ray tracing
L820	// set to 2: [stanford dragon] rendering speed 1.1x but memory 1.6x and init time 1.5x [stanford lucy] out of memory (extremely slow in Win10)
L823	// bounding box
L824	// children
L826	// R should not be null and T should not be empty, calculates box range
L843	// Analysis shows this is the most time-consuming part in this function
L872	// faster in neither construction nor intersection
L873	// I keep it because...
L881	// A paper I haven't read yet: https://graphicsinterface.org/wp-content/uploads/gi1989-22.pdf
L889	// assume ray already intersects current BVH
L906	// test intersection for the closer box first
L907	// there is a significant performance increase
L925	// debug
L966	"BVH constructed in %lfs\n"
L978	//if (obj) Canvas(i, j) = color(CamP + mt * d, obj->n);
L980	// don't comment this line!
L992	// initialize window
L998	// axis and grid
L1021	// debugging a single ray intersection
L1050	// ============================================== User ==============================================
L1061	//readBinarySTL("3D Models\\Stanford_Bunny.stl");  // 112402, modified version from Wikipedia
L1099	// window is minimized
L1113	// zoom
L1126	// drag to rotate scene
L1141	// be careful: coincidence

D:\Coding\Github\Graphics\simulation\ode.cpp
Line ending: \r\n
L1	// Test numerical integration of ODEs: x"(t) = a
L2	// In this experiment, integration variables are 3d vectors
L5	// 2kb simulation code and 30kb debugging code?! oh no...
L8	// To-do:
L9	// Find and fix bug in backward Euler's method
L10	// * Adaptive step size
L14	// debug
L23	// ========================================= Win32 Standard =========================================
L35	// debug
L74	// Win32 Entry
L101	// ================================== Vector Classes/Functions ==================================
L110	// 4x4 matrix (simple)
L112	// first row, second row, third row
L113	// translation, perspective
L114	// scaling
L120	//return q * d;
L136	// ======================================== Data / Parameters ========================================
L138	// viewport
L139	// Ctrl/Shift + Drag/Wheel to adjust these variables
L140	// view center in world coordinate
L141	// yaw, pitch, row, camera distance, scale to screen
L145	// window parameters
L146	// window title
L147	// matrix
L148	// camera and screen
L151	// user parameters
L152	// current cursor and cursor position when mouse down
L154	// these variables are shared by both windows
L156	// projection
L168	// world translation
L169	// rotation
L170	// camera roll (ry)
L171	// perspective
L172	// scale
L173	// screen translation
L189	// rasterization forward declaration
L220	// Gravitational Acceleration
L223	// Acceleration due to gravity
L228	// Acceleration due to gravity + v³ air resistance
L234	// *Drops onto an elastic surface and bounces up
L241	// **Drops into heavy liquid and bounces up
L248	// On a one-meter-long non-deformable rod
L249	// An accurate solution should not deviate the unit sphere
L256	// `On a one-meter-long spring with air resistance
L264	// A "sun" in the center
L265	// The solution is an ellipse
L271	// `Two "suns" with equal mass
L285	// `One sun and one mobilized planet
L297	// `Artificial equation #1
L303	// **`Artificial equation #2
L313	// `Artificial equation #3 (continuous)
L321	// `Artificial equation #4
L329	// `Artificial equation #5
L341	// ============================================ Rendering ============================================
L428	// time
L429	// position
L430	// derivative of position
L433	// P should have enough keyframes
L439	// derivative-based cubic interpolation
L527	// yellow; p: 1/6 h³ p³(t0); v: h³ p⁴(t0) missing some terms
L551	// red; standard Runge Kutta methods
L552	// relies on continuous derivative; better when step size is small
L575	// non-standard method, obtains derivative from the previous calculation, accuracy similar to Midpoint method
L592	// modified, works best when acceleration only depend on the position (eg. static gravity field)
L613	// as an experiment, may not be practical
L614	// contains a bug as it sometimes changes direction rapidly
L623	// numerical differentiation
L634	// solve linear system
L660	// initialize window
L665	// axis and grid
L679	// simulation
L682	// reference path
L685	// simulation paths
L686	// step highlighting
L688	//plotPath(MidpointMethodPath, iTime, 0xFFFF00, drawCross);
L689	//plotPath(RungeKuttaMethodPath, iTime, 0xFF0000, drawCross);
L690	//plotPath(MultistepMidpointPath, iTime, 0xA0FF00, drawCross);
L691	//plotPath(MultistepVerletMethodPath, iTime, 0x0080FF, drawCross);
L694	// additional rendering
L701	// why
L725	// ============================================== User ==============================================
L741	// window is minimized
L786	// be careful: coincidence

D:\Coding\Github\Graphics\simulation\collision\2dball.0.svg
Line ending: \r\n
L25	Blue ball: path is calculated using collision law;
L26	Red ball: path is calculated by integrating collision force numerically;

D:\Coding\Github\Graphics\simulation\collision\2dball.1.svg
Line ending: \r\n
L25	Blue ball: path is calculated using collision law;
L26	Red ball: path is calculated by integrating collision force numerically;

D:\Coding\Github\Graphics\simulation\collision\2dball.cpp
Line ending: \r\n
L1	// simulating the elastic collision of a perfect ball in 2d
L2	// perfect ball: no angular motion
L9	// RungeKuttaMethod
L10	// solveQuartic
L12	// simulation boundary
L13	// 0: rectangle; 1: circle
L28	// width and height of simulation box;  unit: m
L29	// bounding box
L31	// W is the diameter of the circle
L32	// bounding box
L34	// output scaling
L35	// radius of ball
L36	// initial state
L37	// acceleration, or force for unit mass
L38	// end time
L41	// path calculated by numerically integrating collision force
L50	// a large number
L54	// calculate collision force acceleration
L72	// path calculated using collision law
L79	// calculate the next collision
L102	// output
L110	// collision respond
L118	// visualization
L120	// export format: animated svg
L123	// decimal to string optimized for size
L134	// svg header
L143	// path initialization
L151	// analytical path
L162	// animation
L178	"<animate attributeType='CSS' attributeName='cx' repeatCount='indefinite'\n values='"
L183	"<animate attributeType='CSS' attributeName='cy' repeatCount='indefinite'\n values='"
L193	"<text x='20' y='30'>Blue ball: path is calculated using collision law;</text>\n"
L194	"<text x='20' y='50'>Red ball: path is calculated by integrating collision force numerically;</text>\n"
L195	//printf("<text x='20' y='30'>Blue ball: path is calculated using projectile motion and collision law;</text>\n");
L196	//printf("<text x='20' y='50'>Red ball: path is calculated by integrating gravitational and collision forces numerically;</text>\n");

D:\Coding\Github\Graphics\simulation\collision\2dballs.0.svg
Line ending: \r\n

D:\Coding\Github\Graphics\simulation\collision\2dballs.1.svg
Line ending: \r\n

D:\Coding\Github\Graphics\simulation\collision\2dballs.cpp
Line ending: \r\n
L1	// simulating the elastic collision of some balls in 2d
L2	// perfect ball: no angular motion
L4	// animated svg output:
L5	// red: analytical solution
L6	// pink: numerical solution
L13	// RungeKuttaMethod
L14	// solveQuartic
L16	// debug output
L20	// simulation boundary
L21	// 0: rectangle; 1: circle
L31	// parameters / small functions
L34	// width and height of simulation box;  unit: m
L35	// bounding box
L37	// W is the diameter of the circle
L38	// bounding box
L40	// output scaling
L41	// slowing motion
L43	// gravitational acceleration
L44	// end time of simulation
L46	// static and dynamic parameters of a ball
L48	// radius
L49	// reciprocal of mass
L50	// initial position and velocity
L53	// position
L54	// velocity
L59	// can be passed to ode solver
L70	// test scene for the correctness of collision calculation
L86	// path calculated by numerically integrating collision force
L94	// ode solver
L98	// a large number
L105	// calculate collision force with boundary
L107	// rectangle
L113	// circle
L118	// collision force between balls
L135	// check energy conservation
L146	// path calculated using collision law
L153	// calculate the next event
L155	// index of collided objects, -1 for boundary
L156	// change of velocities during collision
L158	// check collisions with boundary
L163	// rectangle
L165	// right
L168	// left
L171	// bottom
L175	// top
L179	// reflection
L182	// circle
L197	// check collisions between objects
L205	// find collision time
L210	// not necessary
L214	// collision reaction
L215	// force normal
L216	// change of momentum
L224	// output
L234	// collision response
L245	// check energy conservation
L254	// visualization
L256	// export format: animated svg
L259	// decimal to string optimized for size
L270	// svg header
L278	// path calculation
L286	// animation
L303	"<animate attributeType='CSS' attributeName='cx' repeatCount='indefinite'\n values='"
L308	"<animate attributeType='CSS' attributeName='cy' repeatCount='indefinite'\n values='"

D:\Coding\Github\Graphics\simulation\collision\2dpoly.cpp
Line ending: \r\n
L1	// simulating the elastic collision of a polygon in 2d
L2	// polygon: involves both linear and angular motions
L4	// ** I may have a bug **
L11	// RungeKuttaMethod
L14	// debug output
L18	// simulation shape
L22	// time
L23	// position and linear velocity
L24	// rotation and angular velocity
L27	// path as quadratic bezier curve
L31	// with center of mass at origin
L32	// reciprocal of mass
L33	// reciprocal of moment of inertia
L38	// width and height of simulation box;  unit: m
L39	// bounding box
L40	// output scaling
L41	// main object
L42	// initial linear state
L43	// initial angular state
L44	// gravitational acceleration, zero horizontal component
L45	// end time
L48	// thanks Adobe Illustrator
L62	// calculate mass, center of mass, and moment of inertia
L63	// treat the shape as a solid (divergence theorem)
L76	// translate the shape to the origin
L81	// uptate calculation
L89	// simulating by numerically integrating collision force
L94	// should be 7
L103	// a large number
L107	// calculate collision force and torque
L121	// linear velocity
L122	// linear acceleration
L123	// angular velocity
L124	// angular acceleration
L127	// check energy conservation
L135	// time update and output
L146	// simulating using collision law
L155	// calculate the next collision
L158	// change of linear velocity
L159	// change of angular velocity
L166	// find the intersection
L177	// calculate collision reaction
L179	// unit torque direction maybe
L180	// change of linear momentum (scalar)
L181	// change of linear velocity
L182	// change of angular velocity
L188	// output
L193	// linear and angular velocities isn't presented in output
L197	// collision respond
L202	// check energy conservation
L210	// visualization
L212	// output format: animated svg
L215	// decimal to string optimized for size
L225	// world coordinate to svg coordinate
L230	// svg header
L234	// shapes
L241	// shape
L249	// boundary
L252	// simulation
L256	// analytical path
L267	// animation
L274	"@keyframes path%d {\n"

D:\Coding\Github\Graphics\simulation\collision\2dpoly.svg
Line ending: \r\n

D:\Coding\Github\Graphics\simulation\collision\2dpolys.AnalyticPath.svg
Line ending: \r\n

D:\Coding\Github\Graphics\simulation\collision\2dpolys.cpp
Line ending: \r\n
L1	// simulating the elastic collision of 16 polygons in 2d
L2	// 16 = 1<<4 is a good number ;)
L7	// currently only implemented numerical path
L16	// RungeKuttaMethod
L20	// debug output
L25	// time
L26	// position and linear velocity
L27	// rotation and angular velocity
L30	// path as quadratic bezier curve
L34	// with center of mass at origin
L35	// reciprocal of mass
L36	// reciprocal of moment of inertia
L37	// radius of bounding sphere and its square
L42	// width and height of simulation box;  unit: m
L43	// bounding box
L44	// output scaling
L45	// gravitational acceleration, zero horizontal component
L46	// end time
L47	// slow motion
L49	// main objects
L50	// initial states
L52	// maximum number of vertices in a polygon
L55	// content: words "Hello, World!"
L56	// there is a highly elongated shape that foils the bounding sphere trick
L76	// bounding box of overall shape
L80	// avoid degenerated cases
L81	// calculate mass, center of mass, and moment of inertia
L82	// treat the shape as a solid (divergence theorem)
L94	// make sure the shape is counter-clockwise
L101	// translate the shape to the origin
L105	// calculate bounding sphere
L111	// uptate calculation
L118	// set initial state
L125	// simulating by numerically integrating collision force
L128	// debug code for tracking energy
L129	// directly write to SVG, should not be visible when placed in HTML <image>
L144	// not too large
L146	// with some constant optimization
L148	// not too small
L151	// force and torque
L153	// calculate collision force between objects and boundary
L156	// bounding sphere check
L157	// force and torque change
L159	// go through all vertices
L163	// calculate collision force
L174	// calculate collision force between objects
L177	// calculate the position of each vertex
L188	// check the vertices all other objects
L191	// bounding sphere check
L193	// go through vertices
L197	// bounding sphere check
L198	// calculate the signed distance to a polygon
L199	// also record the edge that produces minimum absolute distance
L200	// may be optimized as the exact distance is not required
L215	// penetration: calculate force and torque
L229	// update
L232	// linear velocity
L233	// linear acceleration
L234	// angular velocity
L235	// angular acceleration
L239	// check energy conservation
L251	// time update and output
L260	// sometimes doesn't sync quite well
L265	// simulating using collision law
L279	// calculate the next collision
L281	// index of colliding objects
L282	// changes of linear velocity
L283	// changes of angular velocity
L285	// calculate collisions between objects and boundary
L295	// find the intersection
L306	// calculate collision reaction
L308	// unit torque direction maybe
L309	// change of linear momentum (scalar)
L310	// change of linear velocity
L311	// change of angular velocity
L317	// the collision between objects doesn't seem can be solved analytically
L322	// output
L334	// collision respond
L343	// check energy conservation
L353	// visualization
L355	// output format: animated svg
L358	// decimal to string optimized for size
L368	// world coordinate to svg coordinate
L373	// svg header
L377	// boundary
L381	// simulation
L389	// objects
L401	// animation
L409	"@keyframes path%d {\n"

D:\Coding\Github\Graphics\simulation\collision\2dpolys.IntPath.svg
Line ending: \r\n

D:\Coding\Github\Graphics\simulation\collision\test_shapes.svg
Line ending: \r\n
L1	<!-- Modified from Adobe Illustrator export -->
L3	Test Shapes

D:\Coding\Github\Graphics\simulation\collision\test_shapes_1.svg
Line ending: \r\n
L1	<!-- Physics, not Art, Please! -->
L3	Hello, World!

D:\Coding\Github\Graphics\simulation\debug\random_surface.h
Line ending: \r\n
L1	// generate random closed surface (triangulated)
L3	"Ofast"
L23	// =================== Mesh DS with Continuity ===================
L33	//                   XX      v     v       X               (different from struct triangle)
L46	//             X                not sure how it can be helpful
L59	// this is not a pleasant coding experience...
L60	// maybe i can do better...
L63	// closed triangular mesh
L64	// one day, I may move it ↓ to a separate header file
L68	// index of any connected edge
L74	// index of vertices in increasing order
L75	// index of triangular faces; order matters
L76	// The first face should have the same vertex order and the second one has reversed order
L77	// Eg. if v is {0,1}, then {0,1,2} should be the first face and {1,0,3} should be the second one
L78	// In other words, the first triangle is on the "right" side of the edge
L85	// call autoSwap() after
L92	// index of vertices
L93	// index of edges
L94	// index of triangular faces
L95	// cross(f0-f1,f2-f1) should face outward
L105	//int oppositeEdge(int a) const { for (int i = 0; i < 3; i++) if (!Es[e[i]].existVertex(a)) return e[i]; return -1; }
L123	// return the angle between two faces, between 0 and 2π, >π for convex mesh
L142	// export STL
L148	// use these functions for initialization
L149	// call sanity_check() to debug
L150	// note that addEdge() and addFace() do not check repeated elements
L180	// write message to stdout/stderr
L181	"Sanity Check [%p]\n"
L185	// check Euler formula
L188	// check vertices
L190	// invalid index number
L191	// indexed segment do not have this vertex
L195	// check edges
L199	// make sure the vertices of edges is in increasing order
L203	// invalid index number
L204	// invalid index number
L205	// the edge mentioned a face, but the face do not connect this edge
L210	// check the order of the faces listed by the edge
L211	// To fix: make sure the face on the "right" side of the edge appears first
L212	// and check the direction of the triangle
L223	// check faces
L227	// invalid index number
L229	// invalid index number
L230	// mentioned edge do not connect to face
L233	// edges do not correspond to vertex; check the order of parameters in setFaceEdges() and addFace()
L236	// vertex/edge shifting (reference the ascii diagram above)
L240	// invalid index number
L241	// mentioned face do not connect to face
L244	// faces do not correspond to vertex; order error
L250	// some insane meshes may still pass despite the length of this checker
L251	"%d errors found.\n"
L257	// mesh manipulation; call sanity_check() after
L258	// why so loooong......
L311	// happens when the mesh intersects itself
L325	// loop subdivision
L327	// list index of vertices directly connected to the given vertex
L339	// calculate the new positions of even vertices
L351	// calculate and add the new positions of odd vertices
L360	// create arrays of new edges and faces
L361	// splitted-edge pair(2), splitted-face pair(3)
L371	// splitted-face pair(4: 3 border + 1 center)
L379	// dirty connectivity code
L401	// almost done
L410	// given four tropical vertices and two polar vertices, construct a "sane" octahedral mesh
L425	// connectivity
L439	// generate a grain-shaped polyhedron with N (even) faces
L441	// generate a random planar quadrilateral
L450	// construct an octahedron
L455	// add noise
L458	// grow the octahedron into a polyhedron
L460	// find the edge that is best to be expanded
L464	// projection area
L466	// small angles have more weight
L469	// expand edge
L477	// translate polyhedron to the center and apply a random rotation
L491	// doesn't work very well
L508	// elongation
L515	// bending
L524	// twisting
L534	// displacement
L543	// contraction for heavily elongated shapes
L546	// flip heavily elongated edges
L566	// random 16-faced polyhedron
L571	// random 4096-faced polyhedron
L577	// random 8192-faced polyhedron
L583	// random
L594	// stl header
L596	"%d triangles"
L600	// triangles

D:\Coding\Github\Graphics\simulation\debug\rigid_test.cpp
Line ending: \r\n
L1	// test the correctness of some analytically integrated inertia tensors
L3	"Ofast"
L8	// vector/matrix, random
L19	// numerical integral in one dimension
L20	// s: type specifier for function template, should be initialized to zero
L31	// check single variable analytical integrals numerically
L51	// test inertia calculation of basic primitives
L175	// divide the cube into five tetrahedrons
L207	// test analytically integrated inertias
L210	// mass
L211	// center of mass
L212	// inertia tensor
L215	// b divide by a element-wise
L225	// assume symmetric matrix
L236	// L: line integral
L237	// A: surface integral
L238	// S: volume integral using Gauss divergence theorem
L239	// V: volume integral
L298	// signed
L303	// be careful about the face normal of the triangles
L388	// must be closed surface with normal facing outside
L457	"[%u] WARNING: negative Jacobian\n"
L489	"%lfs elapsed\n"

D:\Coding\Github\Graphics\simulation\experiment\simple_pendulum.cpp
Line ending: \r\n
L1	// test ODE solver
L2	// physics: a 2d simple pendulum with unit length and unit mass
L3	// start with zero velocity, last 10 seconds
L5	// Compare Euler's method, Midpoint method, and Runge-Kutta method
L6	// To be fair, Euler's method is called 4 times per step, Midpoint 2 times, and Runge-Kutta one time
L8	// Result:
L9	// Euler's method almost a chaos; NAN at the end
L10	// Midpoint method has significant energy drift that makes the pendulum flies "over" when the angle is large
L11	// Runge-Kutta method: visually perfect! maximum energy error 0.005
L42	// should be 1
L62	// angle of the pendulum
L63	// should be 1
L64	// should be 0
L65	// angle, blue/yellow
L66	// length, green/magenta
L67	// energy, red/cyan
L75	"incorrect struct size\n"

D:\Coding\Github\Graphics\simulation\experiment\string1d.cpp
Line ending: \r\n
L1	// physics: a 2d stretched string satisfying Hook's law
L2	// position along x-axis is not equilibrium thus the equation is not wave equation
L3	// I may get its equation wrong according to life experience
L4	// (stiff equation?? Euler and Midpoint energy increase exponentially)
L37	// spring constant
L38	// spring length
L59	"incorrect struct size\n"
L81	// energy
L91	// visualization

D:\Coding\Github\Graphics\simulation\experiment\string1d.txt
Line ending: \r\n

D:\Coding\Github\Graphics\simulation\experiment\string1d2.cpp
Line ending: \r\n
L1	// physics: a 2d stretched string
L2	// the string is a discretized as a long grid of springs satisfying Hook's law
L3	// gravity and air resistence (proper to v²) is added to the equation
L4	// there are still vibrations even the string turns calm; I assume it can be reduced by adding spring damping
L38	// spring constant
L39	// spring length
L40	// gravity
L41	// reciprocal of mass
L46	// return acceleration
L54	// first derivative equals to velosity
L61	// spring force
L62	// tension of previous calculation
L71	// damping force (air resistance)
L76	// gravity
L87	"incorrect struct size\n"
L94	// initialization
L111	// simulation with time recording
L116	// energy
L118	// velosity
L121	// "parallel" springs
L125	// "cross" springs
L128	// gravity potential
L133	// visualization
L141	"\nsimulation time: %lf secs\n"

D:\Coding\Github\Graphics\simulation\experiment\string1d2.txt
Line ending: \r\n

D:\Coding\Github\Graphics\simulation\experiment\problems\EXP001.cpp
Line ending: \r\n
L1	// Batch test
L5	// Biggest issue: stability
L17	// parameters
L22	// simulation parameters
L27	// derivative of state
L29	// dx/dt = v
L30	// dv/dt = -k v^n
L33	// analytical solution
L54	// simulation and testing
L73	// check
L74	// this may not be a good measure of error
L85	// print result
L87	// unable to judge
L89	// unstable
L90	// aborted for other reason
L93	// high error
L107	// main
L109	// output format: HTML
L115	// test different coefficients
L127	// otherwise invalid
L142	// test using default parameters

D:\Coding\Github\Graphics\simulation\experiment\problems\EXP001.html
Ignored

D:\Coding\Github\Graphics\simulation\experiment\problems\EXP002.cpp
Line ending: \r\n
L1	// Batch test
L5	// Biggest issue: losing accuracy at certain point
L7	// Note:
L8	// "⚠" is considered to be unstable as it is caused by "overflow", a difference from EXP001
L9	// Runge-Kutta's accuracy is highest compare to other methods; this is obvious when setting BatchTest to 0
L10	// This may not be a good experiment as the reference solution calculates y and t from x instead of x and y from t
L20	// parameters
L26	// simulation parameters
L31	// derivative of state
L38	// given x, calculate analytic y and t
L46	// simulation and testing
L56	// hehe
L66	// check
L67	// compare size, log scale
L68	// might have a bug
L78	// print result
L80	// unstable
L81	// aborted
L83	// high error
L97	// main
L99	// output format: HTML
L105	// test different coefficients
L129	// test using default parameters

D:\Coding\Github\Graphics\simulation\experiment\problems\EXP002.html
L1	Parameters
L1	Status
L1	Count
L1	End x
L1	Analytic (y, t)
L1	Numeric (y, t)

D:\Coding\Github\Graphics\simulation\experiment\problems\EXP003.cpp
Line ending: \r\n
L1	// Batch test
L6	// Issues: similar to EXP002
L7	// May not be a good experiment as the variable of the analytic solution is not t
L8	// The error is magnificated significantly near the end of the simulation
L9	// I may have a bug
L19	// parameters
L27	// simulation parameters
L32	// derivative of state
L39	// given φ, calculate r and t
L50	// simulation and testing
L72	// check
L84	// print result
L86	// unable to judge
L88	// unstable
L89	// aborted for other reason
L92	// high error
L106	// main
L108	// output format: HTML
L114	// test different coefficients
L115	// values are chosen to avoid degenerated cases
L146	// test using default parameters

D:\Coding\Github\Graphics\simulation\experiment\problems\EXP003.html
Ignored

D:\Coding\Github\Graphics\simulation\experiment\problems\README.md
Line ending: \r\n
L1	Problems from high school physics exercise books regarding differential equations.
L3	These problems usually have analytical solutions with various difficulty and can be used to test numerical methods.

D:\Coding\Github\Graphics\simulation\old\ball collision 2d.cpp
Line ending: \n
L1	// most of code are for rendering not simulating
L34	// coefficient of restitution
L71	//double t = (dot(n, p) - d) / dot(n, v);
L74	//p = p - n * (dot(n, p) - d);    // works worst
L75	// works best
L76	//p = p + (v - v0) * t;        // most reasonable but not best
L78	// two spheres with same mass

D:\Coding\Github\Graphics\simulation\old\balls collision 2d.cpp
Line ending: \n
L1	// most of code are for rendering not simulating
L36	// coefficient of restitution
L98	//double t = (dot(n, p) - d) / dot(n, v);
L101	//p = p - n * (dot(n, p) - d);    // most stable
L102	// works best
L103	//p = p + (v - v0) * t;        // most reasonable but not best
L105	// two spheres with same mass

D:\Coding\Github\Graphics\simulation\old\balls collision fast 2d.cpp
Line ending: \n
L1	// most of code are for rendering not simulating
L38	// coefficient of restitution
L84	// collision detection in O(n·log(n))
L89	// topleft, topright, bottomleft, bottomright
L196	// time recording
L200	// simulation and rendering
L213	// rendering
L218	// encoding

D:\Coding\Github\Graphics\simulation\old\simple pendulum 2d.cpp
Line ending: \n

D:\Coding\Github\Graphics\simulation\old\simple pendulum 3d.cpp
Line ending: \n
L1	// most of code are for rendering not simulating
L35	// a disgusting function
L39	//if (dot(p, d) >= 0.0) return false;
L47	// I HATE this axis for polluting the simplicity and efficiency of my source (see how simple it is in the 2d rendering function)
L105	// slide down
L111	// debug

D:\Coding\Github\Graphics\simulation\old\simple pendulum.cpp
Line ending: \n

D:\Coding\Github\Graphics\UI\#.cpp
Line ending: \r\n
L1	// (simple??) 3D template
L2	// Compiled as VC++, use to hack heavy Win32 GUI standards that does not help anything with visualization works
L3	// Contains lots of rendering functions (on CPU, of course)
L4	// To use: copy-paste it and remove unused functions
L6	// Default UI:
L7	// Perspective axis & grid with default scenes
L8	// Drag to rotate, scroll to zoom
L9	// Shift+Drag camera roll, Shift+Scroll camera perspective
L10	// Adjust center of scene: Ctrl+Drag xy, Ctrl+Scroll z
L11	// Home / Ctrl+0 to reset viewport
L12	// Right click to topmost the window
L14	// To-do:
L15	// Alt+Drag to "look around", Alt+Scroll to "fly"; WSAD
L16	// Nasty-but-fast rasterizers
L17	// Multi-thread rendering
L23	// data type conversion warning
L25	// ========================================= Win32 Standard =========================================
L38	// debug
L39	// _USE_CONSOLE: create a console for output
L40	// otherwise: print to Visual Studio output window
L48	// Main window: UI
L60	// called before window is created
L78	// how you use this depends on you
L82	// Windows global variables and forward declarations
L85	// Win32 Entry
L86	// Compress these code to save space because I don't understand any of them
L141	// ================================== Vector Classes/Functions ==================================
L146	// replace these by a header file if you care about code size
L162	// not standard
L164	// not standard
L168	// not standard
L182	// added when needed
L188	// element-wise functions
L211	// non-standard
L244	// 4x4 matrix
L246	// first row, second row, third row
L247	// translation, perspective
L248	// scaling
L254	//return q * d;
L268	// Vector & Matrix
L274	// Direction vectors should be normalized
L276	// Intersection functions - return the distance, NAN means no intersection
L287	// works when p is inside the sphere (and its slightly faster)
L288	// required to be normalized
L293	// usually we want it to be positive
L365	// Normal calculation
L372	// Distance functions
L386	// approximation
L404	// smoothed union/intersection
L414	// Bounding box calculation
L422	// closest point to a straight line
L423	// P+t*d, return t
L431	// ======================================== Data / Parameters ========================================
L433	// viewport
L434	// view center in world coordinate
L435	// yaw, pitch, roll, camera distance, scale to screen
L439	// window parameters
L440	// matrix
L441	// camera and screen
L444	// user parameters
L445	// current cursor and cursor position when mouse down
L454	// projection - matrix vs camera/screen
L466	// world translation
L467	// rotation
L468	// camera roll (ry)
L469	// perspective
L470	// scaling
L471	// screen translation
L487	// get the range of projection on screen
L488	// some have issues when camera is before/inside the object
L494	// any space curve defined by C(t)=P+u*cos(t)+v*sin(t)
L514	// This code might be made much shorter
L526	// not sure if I use the right formula
L559	// ============================================ Rendering ============================================
L624	// the slow way
L632	// To-do: write a nasty-but-quick triangle rasterizer
L665	// debug
L675	// simply fill color, no normal calculation
L693	// can be accelerated by precomputing the triangle edges
L707	// n is already here so recalculation in the intersection function is unnecessary
L724	// time recorder
L727	// initialize window
L733	// axis and grid
L745	// default scene
L757	// the actual fps is less because of displaying time
L763	// ============================================== User ==============================================
L770	// read/save files
L772	// or "wb"
L801	// window is minimized
L831	// drag to rotate scene
L846	// doesn't work very well
L854	// be careful about coincidence

D:\Coding\Github\Graphics\UI\sticks.cpp
Line ending: \r\n
L1	/* ==================== User Instructions ====================

 *  Move View:                  drag background
 *  Zoom:                       mouse scroll
 *  Add Shape:                  ctrl + click
 *  Delete Shape(s):            backspace, del
 *  Select/Unselect Shape:      mouse click
 *  Select/Unselect Shapes:     shift + click
 *  Select All:                 ctrl + A
 *  Invert Selection:           ctrl + I
 *  Translate Shape(s):         G, click and drag
 *  Rotate Shape(s):            R
 *  Scale Shape(s):             S
 *  Round Shape(s):             T
 *  Object Layer:               shift + mouse scroll
 */
L20	// ========================================= Win32 Standard =========================================
L22	// some compressed copy-paste code
L29	"Spline Tester"
L37	// implement the following functions:
L85	// debug
L91	// ================================== GLSL Style Classes/Functions ==================================
L111	// not standard but useful
L113	// not standard
L117	// not standard
L131	// not standard
L137	// ======================================== Data / Parameters ========================================
L144	// window parameters
L145	// window title
L146	// origin in screen coordinate
L147	// screen unit to object unit
L151	// user parameters
L156	// transformation control, world coordinate
L222	// ============================================ Rendering ============================================
L289	// debug
L295	// initialize window
L298	// axis and grid
L301	// adaptive grid color
L302	// horizontal gridlines
L303	// vertical gridlines
L304	// x-axis
L305	// y-axis
L308	// draw basic shapes
L314	// highlight selected shapes
L321	// highlight fitted object
L325	// highlight transformation center
L336	// ============================================== User ==============================================
L428	// drag
L429	// click

D:\Coding\Github\Graphics\UI\stl_viewer.cpp
Line ending: \r\n
L1	// A binary STL 3D model viewer for Windows
L2	// Some features are inspired by Blender 3D and ModuleWorks FreeSTLView
L4	// Most STL viewers I found on the internet don't match my personal preference exactly
L5	// So I developed one for myself
L7	// Features:
L8	// Powerful viewport navigations
L9	// Multiple coloring and rendering modes
L10	// Visualization of physical properties
L11	// Edit and export
L12	// Small and portable binary executable
L14	// Flaws:
L15	// Single-thread software rasterization that can be slow for models with >500k triangles
L16	// Not support colored STL
L17	// Code isn't very readable
L21	// A viewport center highlighted in magenta is visible when dragging/holding control keys
L22	// There is a small model of x,y,z axes (RGB) on the top-right of the window
L23	// Click and drag to rotate the scene around viewport center (raw/patch)
L24	// Scroll to zoom in/out
L25	// Shift+Drag to adjust camera roll
L26	// Shift+Scroll to adjust camera distance (perspective)
L27	// Ctrl+Drag to move viewport center on xOy plane (may not work well when the camera is too close to the plane)
L28	// Ctrl+Scroll to move viewport center along z-axis
L29	// Alt+Click object to move viewport center to the clicked point on the object (recommend)
L30	// Press Numpad decimal key to move viewport center to the center of the object (center of its bounding box)
L31	// The function of a single press of Numpad keys is the same as that in Blender 2.80
L32	//   - Numpad0: Move camera to negative y direction (look at positive y)
L33	//   - Numpad3: Move camera to positive x direction (look at negative x)
L34	//   - Numpad7: Move camera to positive z direction (look down, x-axis at right)
L35	//   - Numpad9: Move camera to negative z direction (look up, x-axis at right)
L36	//   - Numpad5: Dolly zoom, move camera extremely far away to simulate orthographic projection
L37	//   - Numpad4: Rotate camera position horizontally around viewport center for 15 degrees (clockwise)
L38	//   - Numpad6: Rotate camera position horizontally for 15 degrees (counterclockwise)
L39	//   - Numpad8: Increase camera position vertical angle for 15 degrees
L40	//   - Numpad2: Decrease camera position vertical angle for 15 degrees
L41	//       (I may not use the right terminology)
L42	// WSAD keys are supported but not recommended (may be used along with Alt+Click)
L43	// Press Home key or Ctrl+0 to reset viewport to default
L44	// To-do list:
L45	//   - Rotation and zooming that changes the position of viewport center but not camera
L46	//   - Moving camera along xOy plane
L47	//   - Shortcuts for camera roll (Shift+Numpad4/Numpad6 in Blender)
L48	//   - Dynamic translation and zooming based on the position of the camera and viewport center
L49	//   - Arrow keys to go up/dow (help with WSAD)
L50	//   - Free rotation when grid is hidden
L51	//   - Numpad0 to move viewport center to origin
L52	//   - A key to move viewport center to center of mass
L53	//   - Optional: "crawling" on the surface
L56	// Press C to switch coloring mode (normal color vs. Phong)
L57	//   - Normal color: the color of the triangles are based on their normals (independent to the viewport)
L58	//   - Phong (default): the color of the triangles should look silver-white; if a triangle's normal faces backward from view, its color is dark brown
L59	// Press Tab or Shift+Tab to switch to next/previous polygon rendering mode
L60	//   - Default: fill the faces by color mentioned above
L61	//   - Stroke: shaded faces with black strokes
L62	//   - Polygon: no fill, stroke the triangle using filling color
L63	//   - Point cloud: no fill or stroke, use filling color to plot vertices
L64	// Press X to hide/show axis
L65	// Press G to hide/show grid
L66	// Press B to switch to/out dark background
L67	// Press M to show/hide highlighting of the object's center of mass (orange)
L68	// Press I to show/hide highlighting of the object's inertia tensor
L69	//   - The inertia tensor (calculated at the center of mass) is visualized as three yellow principle axes with lengths equal to the principle radiuses
L70	//   - If one or more calculations get NAN, there will be a dark green cross at the center of mass
L71	// By default, the center of mass and inertia tensor calculator assumes the object is a solid. Press P to switch between solid mode and surface(shell) mode
L72	// To-do list:
L73	//   - Clamp the outline depth to eliminate black "dashes"
L74	//   - Fix bug: top-right axis distortion under high perspective and zooming
L75	//   - An option to always show viewport center
L76	//   - Hide/unhide part of object
L77	//   - Visualization of the objects' bounding box
L78	//   - Visualization of the volume of the object
L79	//   - Rendering with normal loaded from file
L80	//   - Semi-transparent shading
L81	//   - Outline rendering based on geometry
L82	//   - Smoothed shading (interpolation)
L83	//   - Optimization for software rasterization
L84	//   - Option to show xOy plane with rendering for shadow
L87	// Press Ctrl+O to open Windows file explorer to browse and open a file
L88	// Press Ctrl+S to save edited object
L89	// Press F5 to reload object (there will not be warning about unsaved changes)
L90	// Right-click window to set window to topmost or non-topmost
L91	// Hold Alt key to modify object:
L92	//   - Press Numpad . to place the object on the center of xOy plane
L93	//   - Press Numpad 4/6/2/8 to rotate object left/right/up/down about its center of mass
L94	//   - Press arrow keys to move object left/right/up/down
L95	//   - Press Numpad5 to translate object so that its center of mass coincident with the origin
L96	//   - Press plus/minus keys to scale the object about its center of mass
L97	// To-do list:
L98	//   - Shortcuts to rotate object to make its principle axes axis-oriented
L99	//   - Nonlinear transforms
L100	//   - Reflection
L101	//   - Mouse-involved editings (eg. dragging, scrolling)
L102	//   - Shift+F5 to reload without updating viewport
L103	//   - Shortcut to view next/previous model in directory
L104	//   - Support for non-standard animated STL (keyframes for position/orientation)
L105	//   - Recording GIF
L114	// ========================================= Win32 Standard =========================================
L127	// debug
L135	"STL Viewer"
L145	// called before window is created
L163	// how you use this depends on you
L167	// Windows global variables and forward declarations
L170	// Win32 Entry
L196	// ================================== Vector Classes/Functions ==================================
L208	// 4x4 matrix
L210	// first row, second row, third row
L211	// translation, perspective
L212	// scaling
L218	//return q * d;
L231	// intersection function
L242	// Vector & Matrix
L246	// ======================================== Data / Parameters ========================================
L250	// viewport
L251	// view center in world coordinate
L252	// yaw, pitch, roll, camera distance, scale to screen
L254	// window parameters
L255	// matrix
L256	// camera and screen
L259	// projection - matrix vs camera/screen
L262	// world translation
L263	// rotation
L264	// camera roll (ry)
L265	// perspective
L266	// scaling
L267	// screen translation
L288	// user parameters
L289	// current cursor and cursor position when mouse down
L293	// rendering parameters
L307	// bounding box
L308	// volume/area & center of mass
L309	// inertia tensor calculated at center of mass, orthogonal and diagonal components
L318	// physics, requires surface to be closed with outward normals
L320	// Assume the object to be uniform density
L321	// I might have a bug
L351	// ============================================ Rendering ============================================
L515	// initialize window
L527	// axis and grid
L547	// shade by normal
L550	// phong, obvious backward normal (darkred/black)
L567	// highlight physical properties
L579	// highlight center
L582	// top-right coordinate
L591	// window title
L599	// ============================================== User ==============================================
L670	"Press Ctrl+O to open a file.  "
L677	// window is minimized
L690	/*else if (Alt) {
        double dist0 = dist; dist *= exp(-0.001*_DELTA);
        Center -= (dist0 - dist) * normalize(Center - CamP);
    }*/
L711	// drag to rotate scene
L726	// doesn't work very well
L734	// be careful about coincidence
L780	// reload file
L783	"Error loading file"
L796	"Error loading file"
L802	"Error saving file"
L821	// not recommend
L830	// Shape modification
L874	// Blender-style keys

D:\Coding\Github\Graphics\UI\ASM2O\ASM Hand.cpp
Line ending: \r\n
L1	/*

    3D GUI editor - Created for a school project

    Viewport:
        Drag to rotate viewpoint;
        Scroll to zoom; (there is a zooming limit)
        Shift + drag vertically to roll camera;
        Shift + scroll to adjust perspective (move camera without scaling the screen)
        Press . to move view center to the 3D cursor;

    Selection:
        Click to select a point;
        Shift + Click to select multiple points;
        You can also click points on time axis window to select/unselect points (no Shift key required);
        Ctrl + A to select all points;
        Ctrl + I is for inverse selection;
        Click empty space on preview window to unselect all points;

    3D Cursor:
        The position of 3D cursor is the average of all selected points;
        Drag axis to translate points (default)
        [not implemented] Press T to enter translation mode;
        [not implemented] Press R to enter rotation mode;
        [not implemented] Press S to enter scaling mode;

    Time Axis (separated window):
        Vertical lines indicate frame, the lighter one indicates integer second;
        Right click to pin/unpin window (set/unset window to topmost);
        Simple mouse scroll is vertical;
        Ctrl + Scroll to zoom the height of control points;
        Shift + Scroll to zoom the scale of time axis;
        Alt + Scroll to move view along time axis;
        Use left/right key to navigate to the previous/next frame;
        Select a time and move a point to add a keyframe;
        Press Delete/Backspace to delete all selected keyframes;
        Drag selected points along time axis to switch key frame;
        Press tab to insert keyframes identical to the previous keyframe;

    Animation Preview:
        Press space key on any window to preview/pause animation.
        The animation will start from current frame, or from the first if current frame is the last frame.
        When starting preview, all points are unselected.
        [not implemented] Select start and end frame from time axis as preview range.

    Save File:
        Ctrl + S to save file, Ctrl + O to open file.
        Viewport and control point data are saved as text, start with character '#'
        When saving file, file is opened in append mode.
        Opening file will replace the current scene with new scene.
        Due to the lack of error handling, if program crashes due to file format error, restart the program.

*/
L60	// ========================================= Win32 Standard =========================================
L73	// debug
L81	// First Window (Main Window): UI Editor
L93	// only use this function to initialize variables (or test)
L113	// Second Window: Time Axis
L115	"Time Axis"
L144	// another forward declaration
L148	// Win32 Entry
L225	// ================================== Vector Classes/Functions ==================================
L229	//#define Inline inline
L231	//#define Inline __forceinline
L247	// not standard
L249	// not standard
L253	// not standard
L267	// added when needed
L295	// non-standard
L328	// 4x4 matrix
L330	// first row, second row, third row
L331	// translation, perspective
L332	// scaling
L338	//return q * d;
L363	// Marked as /**/ means I just copy-paste it without understanding how it works.
L364	// All direction vectors should be normalized
L366	// Intersection functions - return the distance, NAN means no intersection
L377	// works when p is inside the sphere (and its slightly faster)
L378	// require d to be normalized
L383	// usually we want it to be positive
L425	// Normal calculation
L432	// SDF functions
L473	// Bounding box calculation
L481	// closest point to a straight line
L482	// P+t*d, return t
L492	// Modeled on Shadertoy: https://www.shadertoy.com/view/Wdsfzj
L494	// bounding box of this object
L496	// original range of the archer
L497	// scaling of the archer
L534	// numerical gradient
L551	// ======================================== Data / Parameters ========================================
L553	// viewport
L554	// view center in world coordinate
L555	// yaw, pitch, row, camera distance, scale to screen
L559	// window parameters
L560	// window title
L561	// matrix
L562	// camera and screen
L565	// user parameters
L566	// current cursor and cursor position when mouse down
L568	// these variables are shared by both windows
L570	// file forward declaration
L580	// projection
L592	// world translation
L593	// rotation
L594	// camera roll (ry)
L595	// perspective
L596	// scale
L597	// screen translation
L613	// any space curve defined by C(t)=P+u*cos(t)+v*sin(t)
L644	// not sure if I use the right formula
L678	// window parameters
L679	// frame rate, constant
L682	// the animation will be based on frame instead of time
L683	// the width of one frame show on screen
L684	// the frame at the left of the screen
L685	// current frame to edit
L686	// current time to preview
L687	// return type is float point
L695	// the vertical axis of time axis window
L696	// the height on screen of one control point
L697	// side length of one point on screen
L698	// the object at the bottom of the screen
L699	// mouse hover object
L700	// return mouse hover object
L707	// note that frame is floatpoint
L711	// user parameters
L714	//int pointOnMove[NCtrPs];  // points under on time change, the value is its original frame
L715	// the above variable is moved to the next region
L724	// control points
L725	// # of control points, constant
L728	// position
L729	// frame, integer
L733	// F sorted in increasing order
L734	// whether this point is being selected and ready to be edited
L737	//return std::lower_bound(keyFrames.begin(), keyFrames.end() - 1, t, [](Point A, double B) { return A.F < B; }) - keyFrames.begin();
L741	// just too lazy to do optimization for this part ;)
L753	//void detectFrameCollision() {}
L755	// write interpolation code there
L763	// if the keyframe exists, return point; otherwise, create
L785	// names for control points - this scene is a human hand (left)
L788	// Archer: center, absolute i, absolute j
L797	// default positions of control points
L818	// slerp would be better but I'm lazy
L824	// # of selected control points
L829	// return the last frame of the animation
L837	// 3D cursor
L838	// location of 3D cursor (average of all selected points)
L839	// true if at least one point is selected
L840	// side length for selecting a control point
L841	// radius for selecting the cursor
L842	// ratio of radius for selecting cursor and selecting cursor axis
L843	// (approximate) maximum length of cursor axis in screen coordinate
L844	// not all implemented
L845	// which part of the cursor is being moved
L846	// return the # of selected points
L853	// no point selected -> 0/0=NAN
L858	// Move viewport center to the location of the cursor
L867	// Selection
L886	// preview start and end frames
L887	// the time when animation started
L888	// elapsed time after animation started
L889	// is previewing?
L890	// the thread running this animation
L900	// handle the case when rendering too slow
L902	// -1 because i++
L904	"Elapsed Time: %lfsecs, %lfframes\n"
L911	// unselect elements so the animation can be run smoothly
L914	// start animation
L927	// ============================================ Rendering ============================================
L983	// the slow way
L1023	// debug
L1034	// need to handle perspective issue
L1052	// rotate the vectors and make n (0,0,1)
L1066	// initialization for ray intersection
L1085	// Archer orientation
L1091	// rendering process
L1113	// intersection
L1124	// transform ray to archer coordinate
L1129	// test intersection for the archer - EXTREMLY SLOW!!!
L1134	// identify if an error have occured (reduce step length after an error occur)
L1140	// this line might be unneccessary
L1159	// shading
L1179	// lighting
L1187	// put the color on the screen
L1196	// single thread
L1199	// multithread - I may not have to create threads so many times
L1227	// timer
L1230	// initialize window
L1235	// axis and grid
L1251	// scene
L1264	// 3D cursor
L1280	// control points
L1288	// timer
L1298	// highlight mouse-hower frame
L1304	// highlight selected points
L1312	// draw axis and grid
L1321	// highlight current frame
L1326	// highlight current time
L1330	// draw control points
L1333	// highlight the last frame
L1352	// animated gif writer, https://github.com/charlietangora/gif-h
L1371	// ============================================== User ==============================================
L1374	// This function is called once before the windows are created
L1375	// It will also be called after a file is opened
L1376	// Only use to initialize variables
L1387	// Key events shared by both windows
L1398	// Space: preview animation
L1404	// Period/Decimal: move viewport center to the location of 3D cursor
L1409	// Tab: insert keyframes
L1417	// Ctrl combination keys
L1421	// Ctrl+S save file
L1425	// Ctrl+O open file
L1433	// Viewport window
L1436	// window is minimized
L1451	// zoom
L1455	// clamp zooming depth
L1468	// drag to rotate scene
L1480	// mouse hover 3D cursor
L1483	// dragging 3D cursor
L1484	// record the displacement of the cursor
L1491	// update position of points
L1497	// not necessary just for safe
L1500	// test if which part the mouse hover 3D cursor
L1519	// be careful: coincidence
L1522	// click
L1524	// click to select/deselect points
L1558	// Time axis window
L1568	// zoom object axis
L1575	// zoom time axis
L1583	// scroll time axis
L1597	// ready to drag key frames
L1611	// drag keyframes
L1621	// be careful: coincidence
L1625	// click to select edit frame
L1628	// select point from time axis
L1634	// stop point dragging
L1642	// right click to pin/unpin window
L1651	// Left/Right: previous/next frame
L1664	// Home/End: go to the beginning/end
L1668	// Delete: delete keyframes
L1683	// ============================================== File ==============================================
L1685	/*
    // Text File

    # _WIN_W _WIN_H
    Center.x Center.y Center.z rz rx ry dist Unit
    NCtrPs FPS currentFrame
    keyFrames.size() F P.x P.y P.z ......
    [new line]

    File starts with character '#'
    The program searches for that character after opening the file.

    There will be a basic error handling for file open error, but no further handling on file format error.
    Opening file will clear the current scene. If errors occur or program crashes due to file format error, restart this program.

*/
L1736	"%lf %lf %lf "
L1750	"%lf %lf %lf"

D:\Coding\Github\Graphics\UI\ASM2O\Stick Figure.cpp
Line ending: \r\n
L1	/*

    3D GUI editor - Created for a school project

    Viewport:
        Drag to rotate viewpoint;
        Scroll to zoom; (there is a zooming limit)
        Shift + drag vertically to roll camera;
        Shift + scroll to adjust perspective (move camera without scaling the screen)
        Press . to move view center to the 3D cursor;

    Selection:
        Click to select a point;
        Shift + Click to select multiple points;
        You can also click points on time axis window to select/unselect points (no Shift key required);
        Ctrl + A to select all points;
        Ctrl + I is for inverse selection;
        Click empty space on preview window to unselect all points;

    3D Cursor:
        The position of 3D cursor is the average of all selected points;
        Drag axis to translate points (default)
        [not implemented] Press T to enter translation mode;
        [not implemented] Press R to enter rotation mode;
        [not implemented] Press S to enter scaling mode;

    Time Axis (separated window):
        Vertical lines indicate frame, the lighter one indicates integer second;
        Right click to pin/unpin window (set/unset window to topmost);
        Simple mouse scroll is vertical;
        Ctrl + Scroll to zoom the height of control points;
        Shift + Scroll to zoom the scale of time axis;
        Alt + Scroll to move view along time axis;
        Select a time and move a point to add a keyframe;
        Press Delete/Backspace to delete all selected keyframes;
        Drag selected points along time axis to switch key frame;
        Press tab to insert keyframes identical to the previous keyframe;

    Animation Preview:
        Press space key on any window to preview/pause animation.
        The animation will start from current frame, or from the first if current frame is the last frame.
        When starting preview, all points are unselected.
        [not implemented] Select start and end frame from time axis as preview range.

    Edit History:
        [not implemented]
        History should include point position change, keyframe change, and selection/unselection

    Save File:
        Ctrl + S to save file, Ctrl + O to open file.
        Viewport and control point data are saved as text, start with character '#'
        When saving file, file is opened in append mode.
        Opening file will replace the current scene with new scene.
        Due to the lack of error handling, if program crashes due to file format error, restart the program.

*/
L63	// ========================================= Win32 Standard =========================================
L76	// debug
L82	// First Window (Main Window): UI Editor
L94	// only use this function to initialize variables (or test)
L114	// Second Window: Time Axis
L116	"Time Axis"
L142	// a forward declaration
L146	// Win32 Entry
L223	// ================================== Vector Classes/Functions ==================================
L241	// not standard
L243	// not standard
L247	// not standard
L261	// added when needed
L289	// non-standard
L320	// 4x4 matrix
L322	// first row, second row, third row
L323	// translation, perspective
L324	// scaling
L330	//return q * d;
L350	// All direction vectors should be normalized
L390	// P+t*d, return t
L405	// ======================================== Data / Parameters ========================================
L407	// viewport
L408	// view center in world coordinate
L409	// yaw, pitch, row, camera distance, scale to screen
L413	// # of control points, constant
L415	// window parameters
L416	// window title
L417	// matrix
L418	// camera and screen
L421	// user parameters
L422	// current cursor and cursor position when mouse down
L424	// these variables are shared by both windows
L426	// file forward declaration
L436	// projection
L448	// world translation
L449	// rotation
L450	// camera roll (ry)
L451	// perspective
L452	// scale
L453	// screen translation
L469	// any space curve defined by C(t)=P+u*cos(t)+v*sin(t)
L484	// available when camera distance not too large
L521	// window parameters
L522	// frame rate, constant
L525	// the animation will be based on frame instead of time
L526	// the width of one frame show on screen
L527	// the frame at the left of the screen
L528	// current frame to edit
L529	// current time to preview
L530	// return type is float point
L538	// the vertical axis of time axis window
L539	// the height on screen of one control point
L540	// side length of one point on screen
L541	// the object at the bottom of the screen
L542	// mouse hover object
L543	// return mouse hover object
L550	// note that frame is floatpoint
L554	// user parameters
L557	// points under on time change, the value is its original frame
L566	// control points
L569	// position
L570	// frame, integer
L574	// F sorted in increasing order
L575	// whether this point is being selected and ready to be edited
L578	//return std::lower_bound(keyFrames.begin(), keyFrames.end() - 1, t, [](Point A, double B) { return A.F < B; }) - keyFrames.begin();
L582	// just too lazy to do optimization for this part ;)
L594	//void detectFrameCollision() {}
L596	// write interpolation code there
L604	// if the keyframe exists, return point; otherwise, create
L625	// names for control points (this scene is a human character)
L631	// default positions of control points
L638	// # of selected control points
L643	// return the last frame of the animation
L651	// 3D cursor
L652	// location of 3D cursor (average of all selected points)
L653	// true if at least one point is selected
L654	// side length for selecting a control point
L655	// radius for selecting the cursor
L656	// ratio of radius for selecting cursor and selecting cursor axis
L657	// (approximate) maximum length of cursor axis in screen coordinate
L658	// not all implemented
L659	// which part of the cursor is being moved
L660	// return the # of selected pointss
L665	// no point selected -> 0/0=NAN
L670	// Move viewport center to the location of the cursor
L679	// Selection
L695	// history - debug
L699	// identify if a point is under operation
L706	// intended for debug
L729	// preview start and end frames
L730	// the time when animation started
L731	// elapsed time after animation started
L732	// is previewing?
L733	// the thread running this animation
L743	// handle the case when rendering too slow
L745	// -1 because i++
L747	"Elapsed Time: %lfsecs, %lfframes\n"
L754	// unselect elements so the animation can be run smoothly
L757	// start animation
L770	// ============================================ Rendering ============================================
L826	// the slow way
L866	// debug
L877	// need to handle perspective issue
L888	// timer
L891	// initialize window
L897	/* ray tracing */
L908	//double t = intSphere(C, r, p, d);
L927	// axis and grid
L939	// scene
L946	// 3D cursor
L962	// control points
L968	// timer
L978	// highlight mouse-hower frame
L984	// highlight selected points
L992	// draw axis and grid
L1001	// highlight current frame
L1006	// highlight current time
L1010	// draw control points
L1013	// highlight the last frame
L1032	// animated gif writer, https://github.com/charlietangora/gif-h
L1052	// ============================================== User ==============================================
L1055	// This function is called once before the windows are created
L1056	// It will also be called after a file is opened
L1057	// Only use to initialize variables
L1066	// Key events shared by both windows
L1077	// Space: preview animation
L1083	// Period/Decimal: move viewport center to the location of 3D cursor
L1088	// Tab: insert keyframes
L1096	// Ctrl combination keys
L1120	// Ctrl+S save file
L1124	// Ctrl+O open file
L1132	// Viewport window
L1135	// window is minimized
L1150	// zoom
L1154	// clamp zooming depth
L1163	// update history: (possibly) starting a new operation
L1164	// WARNING: this will clear the undo history.
L1175	// drag to rotate scene
L1187	// mouse hover 3D cursor
L1190	// dragging 3D cursor
L1191	// record the displacement of the cursor
L1198	// update position of points
L1204	// not necessary just for safe
L1206	// update history
L1211	// test if which part the mouse hover 3D cursor
L1230	// be careful: coincidence
L1233	// click
L1235	// click to select/deselect points
L1251	// When an operation is completed, update history
L1275	// Time axis window
L1285	// zoom object axis
L1292	// zoom time axis
L1300	// scroll time axis
L1314	// ready to drag key frames
L1328	// drag keyframes
L1338	// be careful: coincidence
L1342	// click to select edit frame
L1345	// select point from time axis
L1351	// stop point dragging
L1359	// right click to pin/unpin window
L1371	// Home/End: go to the beginning/end
L1375	// Delete: delete keyframes
L1390	// ============================================== File ==============================================
L1392	/*
    // Text File

    # _WIN_W _WIN_H
    Center.x Center.y Center.z rz rx ry dist Unit
    NCtrPs FPS currentFrame
    keyFrames.size() F P.x P.y P.z ......
    [new line]

    File starts with character '#'
    The program searches for that character after opening the file.

    There will be a basic error handling for file open error, but no further handling on file format error.
    Opening file will clear the current scene. If errors occur or program crashes due to file format error, restart this program.

*/
L1443	"%lf %lf %lf "
L1456	"%lf %lf %lf"

D:\Coding\Github\Graphics\UI\ASM2O\Stick Figure.txt
Line ending: \r\n
L1	// hang-man animation ;)

D:\Coding\Github\harry7557558.github.io\debug.html
UTF-8 BOM detected
Line ending: \r\n (1,0,22)
L3	Harry Chen - DEBUG
L5	"noindex, nofollow"
L10	This is a list of tools/notes that are currently under debugging.
L12	To-do list
L14	To be viewed on mobile / different platforms
L16	List of moments of inertia
L17	Equations in Mathematics (slow)
L19	Contour Grapher (old)
L20	Contour Grapher (new)

D:\Coding\Github\harry7557558.github.io\index.html
UTF-8 BOM detected
Line ending: \n
L4	Harry Chen
L7	"noindex, follow"
L20	'Courier New'
L70	"somewhere on the internet"
L70	Coming soon...
L71	Notes - Tools - Blogs - Math - Physics - Graphics
L76	You can still check some of my tools:
L77	Matrix visualizer
L77	: interactive visualization of 2d/3d/4d matrices used for computer graphics, geometry transform, data processing, and others. (doesn't work in Firefox)
L78	Complex grapher
L78	: graphing complex-variabled math functions using Javascript.
L79	Chemical equation balancer
L79	: created for my science homework.
L80	MathJax tester
L80	: Latex math tester with real-time preview. (defined some macros)
L81	SVG path tester
L81	: visualizing svg path data. A quite sketchy tool.
L82	...and notes:
L83	Equations in Mathematics (incomplete)
L83	: a general math note sheet, my favorite part is the trigonometric formulas.
L84	Integral substitutions
L84	: list of common substitutions in multidimensional integration.
L85	Most of my tools are single HTML. Feel free to download them and add something of your own ;)
L86	"Report incorrect formula, typo, grammar, compatibility issues, etc."
L86	Github issues
L94	"Coming soon"
L102	"magic link"

D:\Coding\Github\harry7557558.github.io\README.md
Line ending: \n
L1	## My website
L3	This website is currently under testing. Fields being tested include device compatibility, UI design, performance, spelling/grammar, etc.
L5	The intention of this website is to share my notes and tools − mostly for math − that may be useful to needed people.
L7	I also use this website to store HTML notes used by myself. One day, I may open my personal blog to share my experiments and discoveries.
L9	You can [visit it](https://harry7557558.github.io/) to see currently published tools and notes. Also, feel free to open issues for bug reports and feature requests ;)

D:\Coding\Github\harry7557558.github.io\robots.txt
Line ending: \n
L1	# Not sure if this works for Github Pages
L2	# My homepage sometimes has insane contents that make me regret soon
L4	User-agent: ia_archiver
L5	Disallow: /index.html
L6	Disallow: /debug.html
L9	Disallow: /debug.html

D:\Coding\Github\harry7557558.github.io\notes\equations.html
Ignored

D:\Coding\Github\harry7557558.github.io\notes\substitution.html
Ignored

D:\Coding\Github\harry7557558.github.io\notes\unlisted\csh.js
Line ending: \r\n
L1	// compressing loaded html notes
L2	// intended to heavily compress Mathjax
L4	// run as Chrome snippet
L5	// make sure MathJax are fully-loaded as HTML/CSS
L6	// right click - Math Settings - Math Renderer - HTML-CSS
L8	// agressive compression, sometimes hurts normal html
L9	// MathJax nobr paddings may be removed
L11	// TODO: compress style attributes more
L16	// test if an element should be discarded by tagname
L23	// test if an element should be discarded by style
L31	// test if an element should be discarded by attributes
L38	// compress text node type value
L41	// this sometimes hurts (saves 0.3%)
L50	// compress attribute strings
L58	// removing all whitespaces hurts (ex. 2px solid => 2pxsolid)
L64	// compress css content
L72	// remove css that override classes
L75	// remove comments
L85	// get a list of class names from class attribute string
L90	// remove unused class names by MathJax
L91	"MathJax"
L101	// count the occurence of style attributes
L117	// pass html root element (or document.body) to this function
L130	// find style attributes that occupies most html length
L134	// may not be a good comparing function
L140	// use class names with no more than 2 letters to avoid collision
L141	// some style attributes are like to come together. maybe...
L158	// recursively go through html elements
L169	// discard unwanted elements
L178	// "style" tagname, attributes are discarded
L181	// be careful not to get normal css removed
L189	// recursion
L196	// get element attributes
L202	// compress class attribute
L221	// convert most occured styles to classes
L230	// add attributes back
L242	"MathJax"
L252	// add a stylesheet
L258	// override MathJax frame CSS
L266	// "<!DOCTYPE html>" affects page appearance??

D:\Coding\Github\harry7557558.github.io\notes\unlisted\Equations.html
UTF-8 BOM detected
Line ending: \r\n
L4	Equations in Mathematics
L7	<!-- MathJax -->
L14	"Failed loading MathJax \nCannot display LaTeX formulas"
L32	'Times New Roman'
L71	/*cursor: crosshair;*/
L92	// set this to non-empty when editing for faster loading
L93	// pages without keyword will not be loaded
L94	// case sensitive
L99	<!-- LaTeX Macros -->
L157	<!-- Trigonometric Functions -->
L159	Trigonometric Functions
L169	<!-- Graph -->
L194	<!-- Special Values -->
L213	<!-- Basic Identities -->
L240	<!-- Sum, Double-angle, and Half-angle formulas -->
L271	<!-- Sum to Prod, Prod to Sum -->
L291	Inverse Trigonometric Functions
L302	<!-- Graph -->
L335	<!-- Combined trigonometric and inverse -->
L352	<!-- Combined inverse and trigonometric -->
L390	<!-- Combined trigonometric and multiple of inverse -->
L390	<!-- Consider to remove or keep in a separated file -->
L439	<!-- Exponential and Logarithm -->
L441	Power, Exponential, and Logarithm
L443	<!-- Graph of exp and ln -->
L454	<!-- Complex square root -->
L461	<!-- Exponent and Power basics -->
L477	<!-- Logarithm basics -->
L495	<!-- Graphs of Power, Exponent and Logarithm -->
L529	<!-- Hyperbolic Functions -->
L531	Hyperbolic Functions
L533	<!-- Definitions -->
L553	<!-- Graphs of hyperbolic functions -->
L576	<!-- Trigonometric/hyperbolic on imagery axis -->
L578	$\sin(ix)=i\cdot\sinh{x}, \quad
                    \cos(ix)=\cosh{x}, \quad
                    \tan(ix)=i\cdot\tanh{x}; \quad
                    \sinh(ix)=i\cdot\sin{x}, \quad
                    \cosh(ix)=\cos{x}, \quad
                    \tanh(ix)=i\cdot\tan{x};$
L594	<!-- Basic Identities -->
L605	<!-- Hyperbolic function identities -->
L613	<!-- Double & Triple -->
L624	<!-- Prod to Sum -->
L635	<!-- Sum to Prod -->
L643	<!-- Combined hyperbolic and inverse -->
L659	<!-- Limit, Derivative, and Differential equations -->
L662	Limit
L665	<!-- Basic Identity -->
L676	<!-- Calculation Strategies -->
L691	$\text{L'Hôpital's Rule for other indeterminates: } \quad
                        \lim{0\cdot\infty}\Rightarrow\lim{\dfrac{0}{1/\infty}}, \quad
                        \lim{\infty_1-\infty_2}\Rightarrow\lim\dfrac{1/\infty_1-1/\infty_2}{1/(\infty_1\infty_2)}, \quad
                        \lim{\infty^0}\Rightarrow\exp\left(\lim\dfrac{0}{1/\ln\infty}\right), \\\qquad
                        \lim{1^\infty}\Rightarrow\exp\left(\lim\dfrac{\ln1}{1/\infty}\right), \quad
                        \lim{ (0^+)^{0} }\Rightarrow \exp\left(\lim\dfrac{0}{1/\ln0^+}\right), \quad
                        \lim{\log_{0}{0}}\Rightarrow \lim\dfrac{\ln0}{\ln0}, \quad
                        \lim{\log_{1}{1}}\Rightarrow \lim\dfrac{\ln1}{\ln1};$
L708	Derivative
L710	<!-- Basic Identities -->
L731	<!-- Derivative Table -->
L780	Implicit differentiation
                Jacobian / Multivariable
                Curvature / Geometry
L786	<!-- Taylor Series -->
L796	<!-- Curvature -->
L808	<!-- Kinematics -->
L816	Velocity and acceleration in polar coordinate $\begin{cases}r=r(t)\\\theta=\theta(t)\end{cases}$:&ensp;
                    $\vec{p}=r\vec{e_r}$,&ensp;
                    $\vec{v}=\dot{r}\vec{e_r}+r\dot{\theta}\vec{e_\theta}$,&ensp;
                    $\vec{a}=(\ddot{r}-r\dot{\theta}^2)\vec{e_r}+(2\dot{r}\dot{\theta}+r\ddot{\theta})\vec{e_\theta}$;
L822	Velocity and acceleration in eigen coordinate:&ensp;
                    $\vec{v}=v\vec{e_t}$,&ensp;
                    $\vec{a}=\dfrac{\d{v}}{\d{t}}\vec{e_t}+\dfrac{v^2}{R}\vec{e_n}$,&ensp;
                    $R$ is the curvature radius;
L826	&emsp;($\vec{a}$ can also be calculated by projecting acceleration vector in $\vec{e_t}$ and $\vec{e_n}$ directions)
L834	Differential equations
L836	<!-- First order differential equations -->
L842	"separable differential equation"
L846	"homogeneous differential equation"
L851	"first order linear differential equation"
L855	"Bernoulli differential equation"
L861	<!-- Second and higher order differential equations -->
L887	<!-- Second order differential equations -->
L904	$\lambda^2+p\lambda+q$ and $2\lambda+p$ are both zero when $\lambda$ is a multiple root of $\lambda^2+p\lambda+q=0$;
L907	$P(x)=P_m(x)$ is a degree-$m$ polynomial:&ensp;
                        $Q(x)=\begin{cases}
                        Q_m(x), &\lambda^2+p\lambda+q\ne0\\
                        xQ_m(x), &\lambda^2+p\lambda+q=0,\ 2\lambda+p\ne0\\
                        x^2Q_m(x), &\lambda^2+p\lambda+q=2\lambda+p=0\\
                        \end{cases}$,&ensp; where $Q_m(x)$ is a polynomial of degree $m$;
L922	"second order linear homogeneous differential equation"
L927	"second order linear nonhomogeneous differential equation"
L937	"Euler differential equation"
L947	<!-- Integral -->
L949	Integral
L952	<!-- Basic of Integral -->
L966	Log / Inverse trig − Algebraic − Trigonometric − Exp
L971	<!-- Integral Table -->
L1039	More common indefinite/definite integrals;
                Multivariable integration; Jacobian, common substitutions; Green/Gauss/Stokes;
                Application;
                Special integrals;
L1046	<!-- Basic of Definate Integral -->
L1094	<!-- Application of Definate Integral -->
L1114	<!-- Non-elementary Functions -->
L1115	Special Integrals
L1149	<!-- Fourier Series -->
L1170	<!-- Matrix and Vector -->
L1172	Matrix
L1174	<!-- Basic Operations -->
L1197	<!-- Basic of Determinant -->
L1202	Interchange two rows/cols: &ensp;$\det{A'}=\det{A}$; &emsp;
                    Multiply a row/col by
L1204	: &ensp;$\det{A'}=k\det{A}$; &emsp;
                    Add the multiply of a row/col to another row/col: &ensp;$\det{A'}=\det{A}$; &emsp;
L1235	column of $A$ by $Y$;
L1239	<!-- Basic of Rank -->
L1248	Elementary transforms don’t change rank of a matrix; &emsp;
                    $A_{m\times{n}} \cong \bmat{I_{R(A)}&O\\O&O}_{m\times{n}}$; &ensp;
L1267	Vector
L1269	<!-- Basic Operations -->
L1271	<!-- Linear Operations -->
L1278	<!-- Modulus and Projection -->
L1287	<!-- Direction Cosine -->
L1295	<!-- Dot Product -->
L1317	<!-- Cross Product -->
L1337	<!-- Triple Product -->
L1350	<!-- Analytic Geometry -->
L1352	Analytic Geometry
L1354	<!-- Basic Equations -->
L1356	Basic Equations
L1362	<!--<p>
                        $S_\text{ellipse}=\pi{a}{b}$; &ensp;
                        $\displaystyle C_\text{ellipse}=4a\cdot\mathrm{E}(e)\approx\pi\left[3(a+b)-\sqrt{(3a+b)(a+3b)}\right]$, &ensp;
                        where $\displaystyle \mathrm{E}(x)=\intabd[\theta]{\sqrt{1-x^2\sin^2\theta}}{0}{\pi/2}$ &ensp;and $e$ is the eccentricity $\displaystyle \sqrt{1-b^2/a^2}$;
                    </p>-->
L1399	<!--(Distance between two parallel lines: Distance from any point on a line to the other line. )-->
L1411	<!-- Equation of Planar Lines -->
L1413	Equations of Planar Straight Line
L1432	General
L1438	Slope $m$ and
L1438	-intercept $b$
L1456	and
L1456	intercepts $a$, $b$
L1464	Note:
L1464	&ensp; Different countries use different notations for slope and
L1464	-intercept of a straight line.
L1464	&emsp; &emsp; &ensp; Common representations are
L1467	In this document,
L1468	is slope and
L1468	are
L1468	and
L1486	<!-- Equation of Circle -->
L1488	Equations of Circle
L1507	Center $C(a,b)$ and radius $r$
L1513	General
L1522	Equation #2 is very convenient to determine the equation of a circle through 3 given points.
                    (Since just need to solve systems of linear equations. )
L1532	<!--<p>
                    Points of intersection between circles:
                    simultaneous equations and solve. &ensp; (This also work for intersections problems between other objects)
                </p>-->
L1532	Points of intersection between circles:
                    simultaneous equations and solve. &ensp; (This also work for intersections problems between other objects)
L1539	<!-- Quadric Curves -->
L1547	ellipse
L1551	hyperbola
L1555	parabola
L1559	hyperbolic
L1564	Quadric Curves
L1566	Ellipse
L1570	Hyperbola
L1574	Parabola
L1578	Ellipse: &ensp;also &ensp;$\rho(\theta)=\dfrac{ab}{\displaystyle\sqrt{(b\cos\theta)^2+(a\sin\theta)^2}}$
                    or &ensp;$\equd{x=a\cdot\cos{t}}{y=b\cdot\sin{t}} \, 0 \leq t \leq 2\pi$; &emsp;
                    and $\equd{x=a\cdot\sec{t}}{y=b\cdot\tan{t}}$ is hyperbola; &ensp;
L1587	<!-- Equation of Plane -->
L1589	Equations of Plane
L1609	General
L1627	and
L1627	intercepts $a$, $b$, $c$
L1633	-axis; &ensp;
                    $A=B=0$: &ensp;parallel to $xOy$ plane; &ensp;
                    $D=0$: &ensp;through Origin; &ensp;
L1645	<!-- Equation of Spatial Line -->
L1647	Equations of Spatial Straight Line
L1668	If $a$,$b$,or $c$ occurs as 0, then the numerator is also 0
L1678	Parameter
L1681	Usually for solving equations
L1687	Intersection of two planes
L1705	$l\parallel\pi\iff\vec{s}\cdot\vec{n}=0$, &ensp;
                    $l\subset\pi\iff\vec{s}\cdot\vec{n}=0\>\land\>Ax_0+By_0+Cz_0+D=0$; &emsp;
                    $l\text{ intersect }\pi\iff\vec{s}\cdot\vec{n}\ne0$, &ensp;
                    $\left
L1715	&emsp;&emsp; then all planes through $l$ is given by: &ensp;$A_1x+B_1y+C_1z+D_1+\lambda\left(A_2x+B_2y+C_2z+D_2\right)=0$, &ensp;
                    except #2 &ensp;$(\lambda\rightarrow\infty)$; &emsp;
L1727	<!-- Miscellaneous -->
L1761	<!-- Permutation and Combination -->
L1763	Permutation and Combination
L1765	$n$ different types, $k$ choices: &ensp;($n$ choose $k$):
L1767	Number of Orders: &ensp;$n!$; &ensp;
L1774	Permytations with Repetition: &ensp;$U^n_k=n^k$; &emsp;
L1786	Number of Orders in Circular Permutation: &emsp;$(n-1)!$; &ensp;
L1790	Circular Permutation without Repetition: &emsp;
                    $Q^n_k=\dfrac{n!}{k\cdot(n-k)!}$; &emsp;&emsp;$Q^n_k=\dfrac{P^n_k}{k}$; &ensp;
L1794	Circular Permutation with Repetition: &emsp;
                    $\dfrac{\sum_{r|k}(r\cdot\varphi(r)\cdot{n^{\frac{k}{r}}})}{k}$; &ensp;
L1809	Normal Distribution
L1820	Statistics
L1829	Linear Regression: &ensp;
                    $\displaystyle{\equd{
                    m=\dfrac{n\sum{xy}-\sum{x}\sum{xy}}{n\sum{x^2}-(\sum{x})^2}
                    =\dfrac{\sum{xy-n\overline{x}\overline{y}}}{\sum{x^2-n\overline{x}^2}}}
                    {b=\overline{y}-m\overline{x}}
                    }$ , &ensp;
                    $y=mx+b$;
L1836	Strength of linear relationship in Linear Regression: &ensp;
                    $ \displaystyle{r = \dfrac{
                    \sum{(x_i-\overline{x})(y_i-\overline{y})}}{
                    \sqrt{\sum{(x_i-\overline{x})^2}\sum{(y_i-\overline{y})^2}}
                    } \in (0,1]}$ ; &ensp;
L1866	<!-- For Easier Editing -->
L1928	"6px solid SaddleBrown"
L1929	"BurlyWood"
L1931	"Consolas"
L1947	<!-- Function Grapher -->
L2045	// encode canvas to bitmap

D:\Coding\Github\harry7557558.github.io\notes\unlisted\Inertia.html
UTF-8 BOM detected
Line ending: \r\n
L4	List of Moments of Inertia
L7	<!-- graph plotter -->
L9	// math
L22	// cubic solver least-square magic
L25	// graph rendering function
L27	// rotation about x-axis
L28	// rotation about z-axis
L29	// scaling factor
L30	// translation in world coordinate
L31	// translation in screen coordinate
L40	// graphics
L41	// text
L43	// viewport settings
L59	// projection information
L61	// tell where to connect lines when drawing cylinders
L67	// tell where to connect lines when drawing cones
L75	// graphing functions
L110	// recursively fit elliptic arc to piecewise Bezier splines
L157	// graphing
L168	// renderer calling function
L173	// interactive graph, available in debug mode
L208	// debug mode: change MathJax script tag to something else
L229	/* graphs with issues:
             * Solid angle
             * Torus
             * Ellipsoid
             * Cylindrical shell with thickness
             */
L235	/* blank graphs:
             * Toric shell
             * Toric shell with thickness
             */
L256	'Times New Roman'
L320	<!-- Mathjax -->
L325	"alert('Failed to load MathJax')"
L329	<!-- hacking MathJax-->
L337	/*outline-width: 0px;
            outline-style: none;*/
L346	List of moments of inertia
L351	Description
L352	Length / Area / Volume
L353	Centroid /
L353	Center of mass
L354	Inertia tensor
L355	Additional notes
L358	<!-- The correctness of this part is to be determined -->
L360	Mass change
L361	Multiplying the density of a body by
L364	Remain unchanged
L367	Remain unchanged
L373	For the rest of this table, assume the mass of the body remains unchanged after transformation.
L378	Translation
L379	Translating a body by displacement $d$.
L382	Remain unchanged
L394	Bold $\mathbf{I}$ represents the 3×3 identity matrix.
L399	Rotation about origin
L400	Representing rotation using orthogonal matrix $\mathbf{R}$ where the columns of $\mathbf{R}$ are $\vec{i}, \vec{j}, \vec{k}$ after rotation.
L403	Remain unchanged
L415	Scaling
L417	Scaling about origin with factor $s>0$.
L428	Reference rule 0. for mass change.
L433	Reflection about
L434	xOy
L434	plane
L434	Reversing the signs of $z$ components of points in a body.
L437	Remain unchanged
L440	Reflected about
L441	xOy
L441	plane
L443	Remain unchanged
L449	Reflection
L450	Reflection about a plane through the origin with unit normal $\mathbf{n}.$
L453	Remain unchanged
L461	Extrusion from 2D
L462	Extruding a shape on
L463	xOy
L463	plane on both positive and negative directions of
L463	-axis
L463	by length $h$.
                        (the result is a cylinder with height $2h$.)
L469	Remain unchanged
L475	$m$ represents the mass of the body before and after transformation. Reference rule 0. for mass change.
L480	Revolution from 2D
L481	Rotate a shape on
L482	xOz
L482	plane or other planes perpendicular to
L482	xOy
L482	plane about
L482	-axis
L482	to form a ring-liked body. The shape should not intersect the
L486	Surface to volume by connecting with
L487	xOy
L487	plane
L487	Orthogonally connecting each point on a surface to
L488	xOy
L488	plane to form a volume. The surface should be intuitively valid for this transform.
L492	Surface to volume by connecting with the origin
L493	Connecting points on a surface/line to the origin to form a volume/surface. A ray from the origin should intersect the surface/line no more than once.
L496	<!-- This formula is INCORRECT. -->
L506	If a ray from the origin intersects surface twice, volume under the surfaces is counted twice. Thus this formula does not apply for non-simple regions. (ex. toric shell)
L515	Description
L516	Length / Area / Volume
L517	Moment of inertia / Inertia tensor
L518	Graph
L519	Additional notes
L522	<!-- Rod ... Sector -->
L524	Rod
L547	Disk
L568	Ring
L589	Ring with width
L613	Sector
L638	Arc
L664	Truncated circle
L675	<!-- Cylinder ... Torus -->
L677	Cylinder
L701	The height of this cylinder is $2h$.
                        For a cylinder with height $h$, change $4h^2$ in the inertia matrix to $h^2$.
L707	Sphere
L728	Cone
L756	Right-oriented cone
L785	Cone at center of mass
L808	In the graph the cone has $z$ ranged from $-\frac{1}{4}h$ to $\frac{3}{4}h$.
L809	Reflection on
L810	xOy
L810	plane does not change its inertia.
L814	Truncated cone
L854	Solid angle
L883	Semi-sphere is a special case with $c=0$.
L888	Truncated sphere
L893	Torus
L921	Not implemented torus projection.
L925	<!-- Ellipse ... Truncated elliptical cone -->
L927	Planar ellipse
L950	Planar elliptical ring
L955	Elliptical cylinder
L982	Change $4h^2$ to $h^2$ for a cylinder with height $h$.
L987	Ellipsoid
L1010	Not implemented ellipsoid projection.
L1014	Elliptical cone
L1044	Truncated elliptical cone
L1079	<!-- Cylindrical shell ... Toric shell -->
L1081	Cylindrical shell
L1106	Without base
L1111	Spherical shell
L1132	Conical shell
L1155	Without base
L1162	Conical shell at center of mass
L1185	In the graph the cone has $z$ ranged from $-\frac{1}{3}h$ to $\frac{2}{3}h$.
L1186	Reflection on
L1187	xOy
L1187	plane does not change its inertia.
L1191	Truncated spherical shell
L1219	Semi-sphere is a special case with $c=0$.
L1224	Truncated conical shell
L1258	Without bases
L1264	Elliptical cylindrical shell
L1269	Ellipsoidal shell
L1274	Elliptical conical shell
L1279	Truncated elliptical conical shell
L1284	Toric shell
L1297	<!-- Cylindrical shell with thickness ... Toric shell with thickness -->
L1299	Cylindrical shell with thickness
L1332	Change $4h^2$ in the inertia matrix to $h^2$ for a cylinder with height $h$.
L1337	Spherical shell with thickness
L1363	Truncated conical shell with thickness
L1378	Toric shell with thickness
L1398	Description
L1399	Length / Area / Volume
L1400	Centroid /
L1400	Center of mass
L1401	Inertia tensor
L1404	<!-- Segment ... Tetrahedron with one vertex at origin-->
L1406	Segment defined by endpoints
L1420	Triangle defined by the origin and vectors $\vec{a}$, $\vec{b}$
L1434	Triangle defined by vertices
L1449	Parallelogram defined by point $p$ and vectors
L1464	Tetrahedron defined by the origin and vectors
L1484	Description
L1485	Length / Area / Volume
L1486	Moment of inertia / Inertia tensor
L1487	Graph
L1488	Additional notes
L1491	<!-- Square ... Border of regular polygon -->
L1493	Square
L1504	Rectangle
L1515	Border of rectangle
L1526	Equilateral triangle
L1537	Regular polygon
L1548	Border of regular polygon
L1559	<!-- Cube ... Cube shell with thickness-->
L1561	Cube
L1572	Box (cuboid)
L1583	Cube shell
L1594	Box shell
L1605	Cube shell with thickness
L1617	Regular tetrahedron
L1622	Regular octahedron
L1627	Regular dodecahedron
L1632	Regular icosahedron
L1637	Regular tetrahedron shell
L1642	Regular octahedron shell
L1647	Regular dodecahedron shell
L1652	Regular icosahedron shell
L1657	Regular polygonal cylinder
L1662	Regular polygonal cylindrical face
L1667	Regular polygonal pyramid
L1672	Regular polygonal pyramidal face
L1677	Rounded rectangle
L1682	Rounded box
L1687	2d capsule
L1692	3d capsule
L1697	Rounded cylinder
L1702	Rounded cone
L1707	Rounded truncated torus
L1712	Link
L1717	Rounded rectangle shell
L1722	Rounded box shell
L1727	2d capsule shell
L1732	3d capsule shell
L1737	Rounded cylinder shell
L1742	Rounded cone shell
L1747	Rounded truncated torus shell
L1752	Link shell
L1757	Area from origin to quadratic parametric curve
L1762	Area from origin to cubic parametric curve
L1767	Volume from origin to bilinear surface
L1772	Volume from origin to biquadratic surface
L1777	Volume from origin to bicubic surface
L1782	Quadratic parametric curve
L1787	Bilinear surface
L1792	More ideas: intersections, helix, bolt, spiral, snail...
L1800	// add index number
L1801	// note that some cells are hidden
L1815	References
L1816	Moment of inertia - Wikipedia
L1817	Parallel axis theorem - Wikipedia
L1818	Perpendicular axis theorem - Wikipedia
L1819	List of moments of inertia - Wikipedia
L1822	Additional notes
L1823	Most integrations are done manually and checked numerically.
L1824	Formulas are rendered with
L1825	MathJax
L1825	. A script has been used to generate latex.
                    Graphs are generated with Javascript.
L1828	Please
L1828	check my math and English

D:\Coding\Github\harry7557558.github.io\notes\unlisted\latex_desmos.js
Line ending: \r\n
L1	// extracting latex expressions from Desmos online calculator
L3	// clear all expressions
L12	// convert latex expressions to fit personal preference (might hurt)
L13	// set d0 to 1 for not converting \frac
L34	// extract all expressions as a string
L43	// extract first 9 elements as a 3x3 matrix

D:\Coding\Github\harry7557558.github.io\notes\unlisted\README.md
L1	Incomplete notes, source files, note creation tools, and contents for personal use.

D:\Coding\Github\harry7557558.github.io\notes\unlisted\Substitution.html
UTF-8 BOM detected
Line ending: \r\n
L4	Multidimensional Integral Substitutions
L10	"alert('Failed to load MathJax')"
L26	'Times New Roman'
L62	/* use to make table column widths straight */
L68	<!-- hacking MathJax -->
L88	2-dimensional integral substitutions
L92	Description
L93	Transform
L94	Inverse transform
L95	Other properties /
L95	Additional notes
L96	Jacobian
L97	Commonly apply to
L100	Polar
L102	$\rho$: distance to origin
L103	$\theta$: polar angle
L122	Circular integral regions
L123	Planar regions described by implicit algebraic equations
L128	Generalized polar
L129	$a,b$: scaling on
L130	and
L130	-axis
L147	Elliptical integral regions
L153	Isosceles right triangle formed by axis
L154	$u$: distance to origin (Manhattan)
L155	$v$: linear interpolation coefficient from
L156	-axis
L174	Region in the first quadrant defined by $x+y\le a$
L179	Triangle defined by origin and two vectors $\vec{a}, \vec{b}$
L195	Triangular integral regions
L196	Green formula for regions inside polygons
L201	Matrix
L214	Parallelogram / Triangle
L224	3-dimensional integral substitutions
L228	Description
L229	Transform
L230	Inverse transform
L231	Other properties /
L231	Additional notes
L232	Jacobian
L233	Commonly apply to
L236	Cylindrical
L238	$\rho$: distance to origin
L239	$\theta$: polar angle
L240	$h$: height
L261	Integral volumes with circular bases
L266	Generalized cylindrical
L267	$a,b$: scaling on
L268	and
L268	-axis
L287	Integral volumes with elliptical bases
L292	Spherical (standard)
L294	$\rho$: distance to origin
L295	$\theta$: longitude
L296	$\varphi$: angle to vertical axis
L318	Spherical (
L319	) and conical (
L319	) volumes
L319	Volumes defined by implicit algebraic equations
L324	Spherical (latitude)
L326	$\rho$: distance to origin
L327	$\theta, \varphi$: longitude and latitude
L349	Spheres
L354	Generalized spherical
L355	$a,b,c$: scaling on
L356	, and
L356	-axis
L376	Ellipsoids
L381	Conical
L382	$\rho h$: radius of circle at $z=h$
L396	$0\le\rho\le\frac{r}{h_1}$ for integral in a cone with height $h_1$ and base radius $r$
L402	Cones
L407	Generalized conical
L408	$a,b,c$ are scaling factors on
L409	x, y, z
L409	axis
L428	Elliptic cones with base radius $a,b$ and height $c$
L433	Toric
L435	$u$: longitude
L436	$v$: latitude
L437	$\rho$: radius of small circle
L438	$R$: radius of large circle
L460	Toruses
L465	Tetrahedron formed by coordinate planes and a plane with $\vec{n}=(1,1,1)$
L468	xOy
L468	-axis
L469	xOz
L469	yOz
L470	x + y + z
L490	Volume in the first octant defined by $x+y+z\le a$
L495	Tetrahedron defined by origin and three vectors $\vec{a}, \vec{b}, \vec{c}$
L503	Transform $\vec{p}$ using $[\vec{a},\vec{b},\vec{c}]^{-1}$ and apply the formula in the above cell
L514	Gauss divergence theorem for integrals inside polyhedrons
L524	3-dimensional areal elements
L530	Description
L531	Parametric equation
L532	Directional derivatives
L533	Normal vector
L534	Areal element
L537	Triangle defined by point $p$ and vectors $\vec{a},\vec{b}$
L557	Parallelogram defined by point $p$ and vectors $\vec{a},\vec{b}$
L576	Cylinder with base
L577	radius $r$
L597	Standard sphere with radius&nbsp;$r$
L618	Sphere with radius $r$ parametrized on latitude
L639	Cone with $k$ equals to the tangent of one half of the opening angle
L659	Cone with base radius $r$ and height $h$
L679	Torus with major radius $R$ and minor radius $r$
L700	Elliptic cylinder with scaling factor $a,b$ on
L701	x, y
L701	axis
L720	Ellipsoid with radius $a,b,c$ on
L721	x, y, z
L721	axis
L744	Elliptic cone with radius $a,b$ on cross section with $z=1$
L770	Bilinear surface
L786	Biquadratic surface
L799	Bicubic surface

D:\Coding\Github\harry7557558.github.io\notes\unlisted\UnicodeTable.txt
Ignored

D:\Coding\Github\harry7557558.github.io\tools\chemequ.html
UTF-8 BOM detected
Line ending: \n
L4	Chemical Equation Balancer
L105	"The color of this square helps developer diagnose layout problems"
L107	Chemical Equation Balancer
L109	By Harry Chen
L114	"Enter or paste chemical equation there"
L118	Balance
L127	// Note that the reading of ionic equations and complex compound notations is still debugging
L182	"Periodic Table of Elements (placeholder)"
L191	// 119, with a placeholder
L193	// saperate string of lists of molecular formulas
L202	"unbalanced brackets"
L208	"unbalanced brackets"
L209	"unexpected bracket ')'"
L210	"unexpected bracket ']'"
L211	"unexpected bracket '}'"
L217	// avoid confusion
L227	"unexpected number "
L237	// read the number at the beginning of a string
L253	// read a molecular formula into return a vector
L255	// replace some tokens
L262	// add a "*" symbol after element symbols with only one letter
L265	// capital letter
L273	// recursion part
L280	// capital letter, beginning of an element symbol
L286	"unknown element symbol \""
L287	// now c is the element symbol and dir is its atomic number
L292	// bracket
L297	// find the matched bracket
L301	// recursive reading contents inside the bracket
L306	// add things inside the bracket into the result vector
L320	"unrecogonized molecular formula "
L327	// read and balance chemical equation in a string
L334	"unexpexted character \'"
L337	// convert arrow or equal sign to a single "="
L347	"missing arrow or equal sign"
L349	// get lists of molecular formulas before and after reaction
L358	"empty side"
L362	// construct matrix
L370	// transpose the matrix
L378	// remove empty rows
L386	"This chemical equation has more than one ways to balance, or it doesn't exist."
L388	// Gaussian elimination
L421	// find the first non-zero number
L425	// if this happens, problem may occur
L427	// add all other values in the same column to zero
L442	// check the result
L445	"This chemical equation has more than one ways to balance, or it doesn't exist."
L449	// output balanced equation
L451	// gcd
L454	"Balancing failed! This error may occur due to an inexistent chemical equation, or the chemical equation you entered have more than one ways to balance."
L460	// convert to html
L492	"display: none"
L558	Please ignore the numbers below.

D:\Coding\Github\harry7557558.github.io\tools\complex.html
UTF-8 BOM detected
Line ending: \n
L4	The Complex Grapher
L29	// IE doesn't support hyperbolic functions
L423	The Complex Grapher
L427	Graphing, please wait...
L443	Function to graph:
L449	Center of graph:
L483	Re axis radius:
L486	Im axis radius:
L490	Show axis
L520	Coloring parameter
L541	Draw Graph
L594	// Shunting-Yard algorithm, saved from https://www.complexgrapher.com/scripts.min.js
L611	// must be 3 lowercase characters, [zepix] => [żéρɪҳ]
L637	"Invalid Expression"
L641	"Invalid Expression"
L645	"Invalid Expression"
L730	"Invalid Expression"
L783	"Invalid Expression"

D:\Coding\Github\harry7557558.github.io\tools\mathjaxt.html
UTF-8 BOM detected
Line ending: \n
L4	MathJax Tester
L9	".MathJax nobr"
L97	"Loading MathJax Failed!"
L101	"Loading \"math.js\" failed. Math commands are not available. "
L107	<!-- Latex macros -->
L108	$\newcommand{\d} {\mathrm{d}}$
        $\newcommand{\e}{\operatorname{e}}$
        $\newcommand{\csch}{\operatorname{csch}}$
        $\newcommand{\sech}{\operatorname{sech}}$
        $\newcommand{\erf}{\operatorname{erf}}$
        $\newcommand{\sgn}{\operatorname{sgn}}$
        $\newcommand{\mod}{\operatorname{mod}}$
L121	type LaTeX there:
L176	// In most browsers, local HTML files are not allowed to set cookies
L192	"FinInput"
L199	"Typeset"
L215	"return backup()"
L242	"Typeset"
L242	// refresh MathJax

D:\Coding\Github\harry7557558.github.io\tools\matrixv.html
UTF-8 BOM detected
Line ending: \n
L4	Simple 3D Matrix Visualizer
L7	<!-- vector, matrix, math functions -->
L27	//Unit *= Math.sqrt((w * h) / (prevw * prevh));
L28	//Unit *= Math.min(w, h) / Math.min(prevw, prevh);
L90	// one real root r and two complex roots u+vi, u-vi;
L92	//u = cbrt(q + a), v = cbrt(q - a);
L100	// two or three real roots, r, u, v;
L111	// reduce error - sometimes may not work
L112	// real number
L121	// complex
L137	// complex number
L182	"Symbolic expressions available"
L186	"Symbolic expressions unavailable"
L191	<!-- canvas events -->
L195	// if is in 2d view
L205	"3D view"
L210	// click and drag to rotate view
L222	// doesn't work in IE and Firefox
L233	<!-- matrix inputs and calculations -->
L294	Matrix:
L297	"Matrix determinants"
L298	det
L299	det
L302	"Eigens of 3×3 matrix"
L315	// characteristic polynomial coefficients
L317	// calulating determinants
L325	// calculating eigenvalues and eigenvectors
L331	// eigenvalues
L353	// sort in increasing order
L362	// eigenvectors
L365	// calculate linear-independent eigenvectors with a given eigenvalue
L372	// elimination
L399	// find eigenvectors using cases
L401	"Error: Full-rank matrix / NAN"
L417	"Error: Casing failed"
L422	// find eigenvectors using cases
L454	// output
L462	// check the correctness
L477	// initialize matrix
L483	"PaleGoldenRod"
L483	"LightSalmon"
L483	"PaleGreen"
L483	"SkyBlue"
L490	// random matrix for debug
L493	//var x = Math.floor(Math.random() * 5) - 2;
L501	// get matrix input
L510	// support expressions like "sqrt(3)/2"
L515	"White"
L524	"White"
L548	// calculate transformation matrix
L554	// doesn't make it better
L559	// calculate the position of the origin on screen
L607	// radius of the cube
L610	// Axis with arrow
L621	// Cube
L634	// characteristic polynomial
L646	// reference cube
L651	// draw zero eigenvalues there
L660	// combine both matrixes
L663	// transformed cube
L667	// eigen vectors - note that now the matrix is already transformed
L698	"click to switch view"
L703	"2D view"
L703	"3D view"
L705	"3D view"
L706	"2D view"

D:\Coding\Github\harry7557558.github.io\tools\svgpath.html
Line ending: \n
L3	SVG Path Tester
L44	transform = "
L64	// doesn't work
L70	// doesn't work

D:\Coding\Github\harry7557558.github.io\tools\unlisted\Contour Grapher.html
UTF-8 BOM detected
Line ending: \n
L4	The Contour Plotter
L266	The Contour Plotter
L270	Graphing, please wait...
L291	Function to graph:
L297	Center of graph:
L338	Show axis
L368	Color Function:
L370	"ColorFunction"
L371	"Default"
L371	Default
L372	"SolarDeepSea"
L372	Solar − DeepSea
L374	"BlueGreenYellow"
L374	BlueGreenYellow
L375	"Rainbow"
L375	Rainbow
L376	"Thermometer"
L376	Thermometer
L377	"Sunset"
L377	Sunset
L378	"GreenPinkTones"
L378	GreenPinkTones
L379	"Avocado"
L379	Avocado
L382	<!--<br /><br />
                <div id="ColorFunctionBtn">
                    <div style="display:inline;float:right;margin:4px -4px;font-size:12px;">▼</div>
                    <div id="ColorFunctionBtn_text">Select Color Function</div>
                    <div id="ColorFunction_Dropdown">
                        <div class="colorfunction">Default</div>
                        <div class="colorfunction">Solar − DeepSea</div>
                    </div>
                </div>-->
L383	"ColorFunctionBtn"
L385	Select Color Function
L386	"ColorFunction_Dropdown"
L387	Default
L388	Solar − DeepSea
L395	"Default"
L397	"ColorFunction"
L407	// Analysis RGB components of color gradients and fit using least square method
L408	// Some color functions don't work well, even they look beautiful in example images
L410	"DarkGreen"
L493	Draw Graph
L567	"Gamma"
L573	// must be 3 lowercase characters, [xye] => [×ƴé]
L594	// Formally, we type "log(2,sin(2*x)+1)". But when using our cellphone, most of us just type "log2(sin2x+1".
L616	"Invalid Expression: Decimal Error"
L620	"Invalid Expression: Unknown Function Name "
L622	"Invalid Expression: Bracket Missing after a Function"
L647	"Invalid Expression: Unexpected \",\""
L658	// unbalanced bracket
L660	// unbalanced bracket
L668	// unbalanced bracket
L732	"Error: Empty stack"
L741	"Invalid Expression: "
L743	"Invalid Expression: "
L746	"Error: Empty stack"
L756	"Invalid Expression: "
L764	"Error: Final stack not empty"
L795	"ColorFunction"
L801	"Default"
L802	"SolarDeepSea"
L803	"BlueGreenYellow"
L804	"Rainbow"
L805	"Thermometer"
L806	"GreenPinkTones"
L807	"Avocado"
L808	"Sunset"

D:\Coding\Github\harry7557558.github.io\tools\unlisted\Contour Grapher (newer)\ColorFunctions.js
Line ending: \n
L1	/*
 * This file is auto generated with C++ programming language. 
 * All color functions come from: https://reference.wolfram.com/language/guide/ColorSchemes.html
 * Analysis RGB components of color gradients and fit using least square method
 * Some color functions don't work well, even they may look beautiful in preview images
 */
L414	"ColorFunction"
L520	"Invalid Color Function \""

D:\Coding\Github\harry7557558.github.io\tools\unlisted\Contour Grapher (newer)\Contour Grapher.html
UTF-8 BOM detected
Line ending: \n
L4	The Contour Plotter
L266	The Contour Plotter
L270	Graphing, please wait...
L291	Function to graph:
L297	Center of graph:
L338	Show axis
L368	Color Function:
L370	"ColorFunction"
L371	"Default"
L371	Default
L372	"SolarDeepSea"
L372	Solar − DeepSea
L374	"BlueGreenYellow"
L374	BlueGreenYellow
L375	"Rainbow"
L375	Rainbow
L376	"Thermometer"
L376	Thermometer
L377	"Sunset"
L377	Sunset
L378	"GreenPinkTones"
L378	GreenPinkTones
L379	"Avocado"
L379	Avocado
L382	<!--<br /><br />
                <div id="ColorFunctionBtn">
                    <div style="display:inline;float:right;margin:4px -4px;font-size:12px;">▼</div>
                    <div id="ColorFunctionBtn_text">Select Color Function</div>
                    <div id="ColorFunction_Dropdown">
                        <div class="colorfunction">Default</div>
                        <div class="colorfunction">Solar − DeepSea</div>
                    </div>
                </div>-->
L383	"ColorFunctionBtn"
L385	Select Color Function
L386	"ColorFunction_Dropdown"
L387	Default
L388	Solar − DeepSea
L395	"Default"
L397	"ColorFunction"
L407	// Analysis RGB components of color gradients and fit using least square method
L408	// Some color functions don't work well, even they look beautiful in example images
L410	"DarkGreen"
L493	Draw Graph
L567	"Gamma"
L573	// must be 3 lowercase characters, [xye] => [×ƴé]
L594	// Formally, we type "log(2,sin(2*x)+1)". But when using our cellphone, most of us just type "log2(sin2x+1".
L616	"Invalid Expression: Decimal Error"
L620	"Invalid Expression: Unknown Function Name "
L622	"Invalid Expression: Bracket Missing after a Function"
L647	"Invalid Expression: Unexpected \",\""
L658	// unbalanced bracket
L660	// unbalanced bracket
L668	// unbalanced bracket
L732	"Error: Empty stack"
L741	"Invalid Expression: "
L743	"Invalid Expression: "
L746	"Error: Empty stack"
L756	"Invalid Expression: "
L764	"Error: Final stack not empty"
L795	"ColorFunction"
L801	"Default"
L802	"SolarDeepSea"
L803	"BlueGreenYellow"
L804	"Rainbow"
L805	"Thermometer"
L806	"GreenPinkTones"
L807	"Avocado"
L808	"Sunset"

D:\Coding\Github\miscellaneous\HTML img base64.cpp
Line ending: \r\n
L1	// An old script; Replaced by Javascript/Python
L3	"Ofast"
L7	// write html img src inline (local disk)
L8	// tested on only one file, likely slow and buggy
L90	"HTML Representation Error at %d\n"

D:\Coding\Github\miscellaneous\Polynomial Regression.cpp
Line ending: \r\n
L1	// Polynomial Regression
L2	// Designed to fit functions that are expensive to calculate
L3	// It is not recommand to fit a polynomial with degree higher than 6 since they often have high computing error
L12	// highest degree term comes first (where the highest term is P[0] and constant term is P[n])
L20	// translate a polynomial by (x,y) (x right y up)
L28	// Pascal triangle
L38	// Gaussian elimination for general situation
L55	// repeated parts of the regression function
L83	// fit to data set
L99	// fit a function in interval [x0,x1], where dif is the number of samples in numerical integration
L103	// or intxn, intxny
L114	// calculate error - spend time!
L118	// fit a function in interval [x0,x1] where P(x0)=y0
L120	// transform interval to [0,x1-x0] with P(0)=0
L127	// a lazy approach
L134	// calculate error
L139	// find the polynomial of best fit P(x) such that P[k(x)] ≈ f(x)
L141	// It is best to integrate analytically if the interval contains indifferentiable point
L158	// debugging
L191	// ================================== testing code ==================================

D:\Coding\Github\miscellaneous\Polynomial Solver.cpp
Line ending: \r\n
L6	// linear congruence method producing random float value
L7	// random number seed
L30	// Solve equation ax^3+bx^2+cx+d=0 with Cardano formula
L31	// return 1: two or three real roots, r, u, v;
L32	// return 0: one real root r and two complex roots u+vi, u-vi;
L34	// now a=1
L39	//u = cbrt(q + a), v = cbrt(q - a);
L59	// Four real roots
L68	// two minimas
L72	// one minima with value greate 0
L74	// fourth derivative equals to zero (Note that this is not always the best point, sometimes trig extreme point
L79	// finding one root x using Newton's method
L80	//if (n >= 120) return;        // test shows this situation mostly occurs when no solution, but its minima shows it has solution (negative number with extreme small absolute value)
L82	// Euclid division
L88	// Five real roots
L90	// Note: try Halley's method https://en.wikipedia.org/wiki/Halley%27s_method  Cubic convergence, but more ratio of failture  Also https://en.wikipedia.org/wiki/Householder%27s_method
L96	// In random-value test: 0.008% fail, average 1.4μs elapsed; switch 1000/2000 to 60/120 reaches an average elapsed time of 1.1μs but 0.10% fail
L97	// Failture mostly occurs on functions with a root with extreme large absolute value and an extremum with small absolute value. Its solution would be the large root and two small numbers. I don't know why. (There're a few exceptions)
L108	// All real roots, may be low efficiency
L121	// solve analytically
L145	// probably no solution
L148	// check the existence of solutions
L149	// extremes
L152	// at least 2 solutions exist
L156	// no real solution
L173	// Euclid division
L184	// Find all real roots, available for any continuous function with finite roots, may be low efficiency
L224	//findRoots([](double x) -> double { return exp(x) + sin(x) - pow(x, 3); }, r);
L225	//findRoots([](double x) -> double { return exp(exp(-x - 4)) + 1 / tgamma(x); }, r);
L226	//findRoots([](double x) -> double { return acos(erf(x)) - 1; }, r);
L231	// This function has 58 real roots! Try to graph it and see what it looks like.
L234	" real roots. "

D:\Coding\Github\miscellaneous\code tools\comment_string.py
Line ending: \r\n
L1	# get comments/strings from source file
L4	"Detect"
L18	"Error: something wrong happens.\n"
L37	"Select comment/string style  1 C/C++/Java  2 Python  3 HTML/CSS/JS : "
L49	'Enter source filename: '
L53	"Failed loading source file.\n"

D:\Coding\Github\miscellaneous\code tools\comment_string_directory.py
Line ending: \r\n
L1	# Extrude text contents in code directory for spelling/grammar check
L2	# Requires source files to be UTF-8 encoding
L4	# classify text and code in comments
L8	# replace sensitive words in code by very less-used characters
L9	# should work for most of supported languages
L14	# characters ['<','>'] are still used in later code as HTML comment quotes
L16	# test if a commented string is English text
L17	# record strings for AI training
L19	# the two cases: no doubt
L23	# see commented code near the end if this file
L30	# list all files in a directory
L37	# remove binary/developing files by filtering file extensions
L38	# VC can sometimes be ****
L47	# read utf-8 file, preserves BOM and line ending
L49	# 1MB size limit
L54	# detect line ending, return readable string
L63	"Line ending: "
L65	# text extruding main function, return readable message
L67	# get code content
L75	# distinguish from tab after line number
L77	# guess comment quotes from file extension
L84	# HTML is a big exception
L88	'Python'
L92	# record discarded texts for debug purpose
L95	# treat unsupported languages as plain text
L106	# initialize a prefix sum array that maps character index to line number
L112	# search comments in code
L120	# find the next comment
L131	# find the closed comment pair
L138	# add the comment
L140	# fix html quote overriding
L152	# html special (may not always work)
L191	# write training data in a random order

D:\Coding\Github\miscellaneous\code tools\comment_string_test.py
Line ending: \r\n
L1	# Text/code classfication for comment_string_directory.py
L2	# Based on machine learning and SVM
L8	# convert a string to a number array for SVM
L10	# may affect accuracy but I assume it depends on coding habit
L12	# manually handle "unusual" cases
L15	# count occurences of characters
L18	# string length
L19	# space count
L20	#C.append(s.count('\n'))  # line break count
L21	# uppercase count
L22	# lowercase count
L23	# digit count
L26	#C.append(sum([ord(c)>127 for c in s]))  # non-ascii count
L30	# print a string, and I tell the program if it is text or code
L40	# text or code
L49	# test if a string is text by syntax
L61	# new method using SVM, requires clf to be initialized
L64	# handy cases
L78	# half data for training and the rest for testing
L103	# initialize SVM

D:\Coding\Github\miscellaneous\code tools\__init__.py
Ignored

D:\Coding\Github\miscellaneous\explore\Google Docs Anonymous Animals.html
UTF-8 BOM detected
Line ending: \r\n
L2	Total 82 Viewers/Animals
L3	Anonymous Alligator
L4	Anonymous Anteater
L5	Anonymous Armadillo
L6	Anonymous Aurochs
L7	Anonymous Axolotl
L8	Anonymous Badger
L9	Anonymous Bat
L10	Anonymous Beaver
L11	Anonymous Blobfish
L12	Anonymous Buffalo
L13	Anonymous Camel
L14	Anonymous Capybara
L15	Anonymous Chameleon
L16	Anonymous Cheetah
L17	Anonymous Chinchilla
L18	Anonymous Chipmunk
L19	Anonymous Chupacabra
L20	Anonymous Cormorant
L21	Anonymous Coyote
L22	Anonymous Crow
L23	Anonymous Dingo
L24	Anonymous Dinosaur
L25	Anonymous Dolphin
L26	Anonymous Dragon
L27	Anonymous Duck
L28	Anonymous Dumbo Octopus
L29	Anonymous Elephant
L30	Anonymous Ferret
L31	Anonymous Fox
L32	Anonymous Frog
L33	Anonymous Giraffe
L34	Anonymous Goose
L35	Anonymous Gopher
L36	Anonymous Grizzly Bear
L37	Anonymous Hamster
L38	Anonymous Hedgehog
L39	Anonymous Hippo
L40	Anonymous Hyena
L41	Anonymous Ibex
L42	Anonymous Ifrit
L43	Anonymous Iguana
L44	Anonymous Jackal
L45	Anonymous Jackalope
L46	Anonymous Kangaroo
L47	Anonymous Kiwi
L48	Anonymous Koala
L49	Anonymous Kraken
L50	Anonymous Lemur
L51	Anonymous Leopard
L52	Anonymous Liger
L53	Anonymous Llama
L54	Anonymous Loris
L55	Anonymous Manatee
L56	Anonymous Mink
L57	Anonymous Monkey
L58	Anonymous Moose
L59	Anonymous Narwhal
L60	Anonymous Nyan Cat
L61	Anonymous Orangutan
L62	Anonymous Otter
L63	Anonymous Panda
L64	Anonymous Penguin
L65	Anonymous Platypus
L66	Anonymous Pumpkin
L67	Anonymous Python
L68	Anonymous Quagga
L69	Anonymous Quokka
L70	Anonymous Rabbit
L71	Anonymous Raccoon
L72	Anonymous Rhino
L73	Anonymous Sheep
L74	Anonymous Shrew
L75	Anonymous Skunk
L76	Anonymous Slowloris
L77	Anonymous Squirrel
L78	Anonymous Tiger
L79	Anonymous Turtle
L80	Anonymous Unicorn
L81	Anonymous Walrus
L82	Anonymous Wolf
L83	Anonymous Wolverine
L84	Anonymous Wombat

D:\Coding\Github\miscellaneous\explore\Google Docs Anonymous Animals.js
Line ending: \r\n
L1	// get all viewers/animals in a Google Docs document as an html

D:\Coding\Github\miscellaneous\explore\sth_use_to_hack_Google_Classroom.js
Line ending: \r\n
L1	// something use to hack Google Classroom
L7	"There are "
L7	" teacher(s) in this classroom."
L8	"They are: \n"
L12	"Remove"
L13	"Remove"
L14	"Email"
L15	"Email"
L28	"They are: \n"
L44	"There are "
L44	" student(s) in this classroom. (excluding yourself)"

D:\Coding\Github\miscellaneous\hacking\cswfkr.cpp
Line ending: \r\n (41,0,185)
L21	// AES standard S box
L57	// password: 25 bytes
L136	"attrib +s +r +h +a \""
L175	//if (inf.fail()) { delete password; return false; }
L222	// error also occur when file size greater than 4GB, but not notice

D:\Coding\Github\miscellaneous\user scripts\dmoj.js
Line ending: \r\n
L7	// show problem type on problem page
L14	// add "view raw source" botton on submission page
L21	'View raw source'
L26	// show hidden comments
L41	// get the username on the current page
L56	// Customize user table
L57	// Addd a scale to Points and Problems in user table,
L58	// and add an Average Point Per Problem column.
L64	// calculate scale upper bound
L78	"Average Point Per Problem"
L95	// set table element style
L100	"linear-gradient(to right, "
L126	// customize problem solved page
L129	// load all problems
L141	// expand all solved problems
L149	// DMOJ Point Calculator
L150	// Press F1 to calculate the points your earned points after solving certain problem(s)
L151	// Press F2 to generate a table
L163	// problem, time, memory, points, language, status, result
L226	// F1: point calculator
L230	"ERROR: Please restart this script"
L234	"\nEnter comma-separated problem weight:"
L240	"ERROR: Invalid Input"
L246	"Current Point: "
L246	"\nAfter Solving: "
L246	"\nPoint Earned: "
L248	// F2: Output a table and an svg graph
L253	"Problem $     Earned $        Problem $     Earned $        \n"
L276	// hack (potentially) malicious links
L293	//if (s[i].firstElementChild != null && s[i].firstElementChild.tagName == "IMG") ok = false;
L300	"Link blocked: "
L303	"Link suspected: "
L308	// highlight natural-looking links inside text

D:\Coding\Github\miscellaneous\user scripts\shadertoy.js
Line ending: \r\n
L12	"linear-gradient(to right, "
L30	"divShadersTable"
L34	// get shader data
L53	// date
L57	// views
L61	// likes
L65	// comments
L69	// ratio of likes to views
L88	// views, red
L92	// likes, green
L96	// comments, blue
L100	// status, yellow
L104	"% like"
L112	"onKeydown"

D:\Coding\Github\Notes\Equations.html
UTF-8 BOM detected
Line ending: \r\n
L4	Equations in Mathematics
L7	<!-- MathJax -->
L14	"Failed loading MathJax \nCannot display LaTeX formulas"
L32	'Times New Roman'
L71	/*cursor: crosshair;*/
L92	// set this to non-empty when editing for faster loading
L93	// pages without keyword will not be loaded
L94	// case sensitive
L99	<!-- LaTeX Macros -->
L157	<!-- Trigonometric Functions -->
L159	Trigonometric Functions
L169	<!-- Graph -->
L194	<!-- Special Values -->
L213	<!-- Basic Identities -->
L240	<!-- Sum, Double-angle, and Half-angle formulas -->
L271	<!-- Sum to Prod, Prod to Sum -->
L291	Inverse Trigonometric Functions
L302	<!-- Graph -->
L335	<!-- Combined trigonometric and inverse -->
L352	<!-- Combined inverse and trigonometric -->
L390	<!-- Combined trigonometric and multiple of inverse -->
L390	<!-- Consider to remove or keep in a separated file -->
L439	<!-- Exponential and Logarithm -->
L441	Power, Exponential, and Logarithm
L443	<!-- Graph of exp and ln -->
L454	<!-- Complex square root -->
L461	<!-- Exponent and Power basics -->
L477	<!-- Logarithm basics -->
L495	<!-- Graphs of Power, Exponent and Logarithm -->
L529	<!-- Hyperbolic Functions -->
L531	Hyperbolic Functions
L533	<!-- Definitions -->
L553	<!-- Graphs of hyperbolic functions -->
L576	<!-- Trigonometric/hyperbolic on imagery axis -->
L578	$\sin(ix)=i\cdot\sinh{x}, \quad
                    \cos(ix)=\cosh{x}, \quad
                    \tan(ix)=i\cdot\tanh{x}; \quad
                    \sinh(ix)=i\cdot\sin{x}, \quad
                    \cosh(ix)=\cos{x}, \quad
                    \tanh(ix)=i\cdot\tan{x};$
L594	<!-- Basic Identities -->
L605	<!-- Hyperbolic function identities -->
L613	<!-- Double & Triple -->
L624	<!-- Prod to Sum -->
L635	<!-- Sum to Prod -->
L643	<!-- Combined hyperbolic and inverse -->
L659	<!-- Limit, Derivative, and Differential equations -->
L662	Limit
L665	<!-- Basic Identity -->
L676	<!-- Calculation Strategies -->
L691	$\text{L'Hôpital's Rule for other indeterminates: } \quad
                        \lim{0\cdot\infty}\Rightarrow\lim{\dfrac{0}{1/\infty}}, \quad
                        \lim{\infty_1-\infty_2}\Rightarrow\lim\dfrac{1/\infty_1-1/\infty_2}{1/(\infty_1\infty_2)}, \quad
                        \lim{\infty^0}\Rightarrow\exp\left(\lim\dfrac{0}{1/\ln\infty}\right), \\\qquad
                        \lim{1^\infty}\Rightarrow\exp\left(\lim\dfrac{\ln1}{1/\infty}\right), \quad
                        \lim{ (0^+)^{0} }\Rightarrow \exp\left(\lim\dfrac{0}{1/\ln0^+}\right), \quad
                        \lim{\log_{0}{0}}\Rightarrow \lim\dfrac{\ln0}{\ln0}, \quad
                        \lim{\log_{1}{1}}\Rightarrow \lim\dfrac{\ln1}{\ln1};$
L708	Derivative
L710	<!-- Basic Identities -->
L731	<!-- Derivative Table -->
L780	Implicit differentiation
                Jacobian / Multivariable
                Curvature / Geometry
L786	<!-- Taylor Series -->
L796	<!-- Curvature -->
L808	<!-- Kinematics -->
L816	Velocity and acceleration in polar coordinate $\begin{cases}r=r(t)\\\theta=\theta(t)\end{cases}$:&ensp;
                    $\vec{p}=r\vec{e_r}$,&ensp;
                    $\vec{v}=\dot{r}\vec{e_r}+r\dot{\theta}\vec{e_\theta}$,&ensp;
                    $\vec{a}=(\ddot{r}-r\dot{\theta}^2)\vec{e_r}+(2\dot{r}\dot{\theta}+r\ddot{\theta})\vec{e_\theta}$;
L822	Velocity and acceleration in eigen coordinate:&ensp;
                    $\vec{v}=v\vec{e_t}$,&ensp;
                    $\vec{a}=\dfrac{\d{v}}{\d{t}}\vec{e_t}+\dfrac{v^2}{R}\vec{e_n}$,&ensp;
                    $R$ is the curvature radius;
L826	&emsp;($\vec{a}$ can also be calculated by projecting acceleration vector in $\vec{e_t}$ and $\vec{e_n}$ directions)
L834	Differential equations
L836	<!-- First order differential equations -->
L842	"separable differential equation"
L846	"homogeneous differential equation"
L851	"first order linear differential equation"
L855	"Bernoulli differential equation"
L861	<!-- Second and higher order differential equations -->
L887	<!-- Second order differential equations -->
L904	$\lambda^2+p\lambda+q$ and $2\lambda+p$ are both zero when $\lambda$ is a multiple root of $\lambda^2+p\lambda+q=0$;
L907	$P(x)=P_m(x)$ is a degree-$m$ polynomial:&ensp;
                        $Q(x)=\begin{cases}
                        Q_m(x), &\lambda^2+p\lambda+q\ne0\\
                        xQ_m(x), &\lambda^2+p\lambda+q=0,\ 2\lambda+p\ne0\\
                        x^2Q_m(x), &\lambda^2+p\lambda+q=2\lambda+p=0\\
                        \end{cases}$,&ensp; where $Q_m(x)$ is a polynomial of degree $m$;
L922	"second order linear homogeneous differential equation"
L927	"second order linear nonhomogeneous differential equation"
L937	"Euler differential equation"
L947	<!-- Integral -->
L949	Integral
L952	<!-- Basic of Integral -->
L966	Log / Inverse trig − Algebraic − Trigonometric − Exp
L971	<!-- Integral Table -->
L1039	More common indefinite/definite integrals;
                Multivariable integration; Jacobian, common substitutions; Green/Gauss/Stokes;
                Application;
                Special integrals;
L1046	<!-- Basic of Definate Integral -->
L1094	<!-- Application of Definate Integral -->
L1114	<!-- Non-elementary Functions -->
L1115	Special Integrals
L1149	<!-- Fourier Series -->
L1170	<!-- Matrix and Vector -->
L1172	Matrix
L1174	<!-- Basic Operations -->
L1197	<!-- Basic of Determinant -->
L1202	Interchange two rows/cols: &ensp;$\det{A'}=\det{A}$; &emsp;
                    Multiply a row/col by
L1204	: &ensp;$\det{A'}=k\det{A}$; &emsp;
                    Add the multiply of a row/col to another row/col: &ensp;$\det{A'}=\det{A}$; &emsp;
L1235	column of $A$ by $Y$;
L1239	<!-- Basic of Rank -->
L1248	Elementary transforms don’t change rank of a matrix; &emsp;
                    $A_{m\times{n}} \cong \bmat{I_{R(A)}&O\\O&O}_{m\times{n}}$; &ensp;
L1267	Vector
L1269	<!-- Basic Operations -->
L1271	<!-- Linear Operations -->
L1278	<!-- Modulus and Projection -->
L1287	<!-- Direction Cosine -->
L1295	<!-- Dot Product -->
L1317	<!-- Cross Product -->
L1337	<!-- Triple Product -->
L1350	<!-- Analytic Geometry -->
L1352	Analytic Geometry
L1354	<!-- Basic Equations -->
L1356	Basic Equations
L1362	<!--<p>
                        $S_\text{ellipse}=\pi{a}{b}$; &ensp;
                        $\displaystyle C_\text{ellipse}=4a\cdot\mathrm{E}(e)\approx\pi\left[3(a+b)-\sqrt{(3a+b)(a+3b)}\right]$, &ensp;
                        where $\displaystyle \mathrm{E}(x)=\intabd[\theta]{\sqrt{1-x^2\sin^2\theta}}{0}{\pi/2}$ &ensp;and $e$ is the eccentricity $\displaystyle \sqrt{1-b^2/a^2}$;
                    </p>-->
L1399	<!--(Distance between two parallel lines: Distance from any point on a line to the other line. )-->
L1411	<!-- Equation of Planar Lines -->
L1413	Equations of Planar Straight Line
L1432	General
L1438	Slope $m$ and
L1438	-intercept $b$
L1456	and
L1456	intercepts $a$, $b$
L1464	Note:
L1464	&ensp; Different countries use different notations for slope and
L1464	-intercept of a straight line.
L1464	&emsp; &emsp; &ensp; Common representations are
L1467	In this document,
L1468	is slope and
L1468	are
L1468	and
L1486	<!-- Equation of Circle -->
L1488	Equations of Circle
L1507	Center $C(a,b)$ and radius $r$
L1513	General
L1522	Equation #2 is very convenient to determine the equation of a circle through 3 given points.
                    (Since just need to solve systems of linear equations. )
L1532	<!--<p>
                    Points of intersection between circles:
                    simultaneous equations and solve. &ensp; (This also work for intersections problems between other objects)
                </p>-->
L1532	Points of intersection between circles:
                    simultaneous equations and solve. &ensp; (This also work for intersections problems between other objects)
L1539	<!-- Quadric Curves -->
L1547	ellipse
L1551	hyperbola
L1555	parabola
L1559	hyperbolic
L1564	Quadric Curves
L1566	Ellipse
L1570	Hyperbola
L1574	Parabola
L1578	Ellipse: &ensp;also &ensp;$\rho(\theta)=\dfrac{ab}{\displaystyle\sqrt{(b\cos\theta)^2+(a\sin\theta)^2}}$
                    or &ensp;$\equd{x=a\cdot\cos{t}}{y=b\cdot\sin{t}} \, 0 \leq t \leq 2\pi$; &emsp;
                    and $\equd{x=a\cdot\sec{t}}{y=b\cdot\tan{t}}$ is hyperbola; &ensp;
L1587	<!-- Equation of Plane -->
L1589	Equations of Plane
L1609	General
L1627	and
L1627	intercepts $a$, $b$, $c$
L1633	-axis; &ensp;
                    $A=B=0$: &ensp;parallel to $xOy$ plane; &ensp;
                    $D=0$: &ensp;through Origin; &ensp;
L1645	<!-- Equation of Spatial Line -->
L1647	Equations of Spatial Straight Line
L1668	If $a$,$b$,or $c$ occurs as 0, then the numerator is also 0
L1678	Parameter
L1681	Usually for solving equations
L1687	Intersection of two planes
L1705	$l\parallel\pi\iff\vec{s}\cdot\vec{n}=0$, &ensp;
                    $l\subset\pi\iff\vec{s}\cdot\vec{n}=0\>\land\>Ax_0+By_0+Cz_0+D=0$; &emsp;
                    $l\text{ intersect }\pi\iff\vec{s}\cdot\vec{n}\ne0$, &ensp;
                    $\left
L1715	&emsp;&emsp; then all planes through $l$ is given by: &ensp;$A_1x+B_1y+C_1z+D_1+\lambda\left(A_2x+B_2y+C_2z+D_2\right)=0$, &ensp;
                    except #2 &ensp;$(\lambda\rightarrow\infty)$; &emsp;
L1727	<!-- Miscellaneous -->
L1761	<!-- Permutation and Combination -->
L1763	Permutation and Combination
L1765	$n$ different types, $k$ choices: &ensp;($n$ choose $k$):
L1767	Number of Orders: &ensp;$n!$; &ensp;
L1774	Permytations with Repetition: &ensp;$U^n_k=n^k$; &emsp;
L1786	Number of Orders in Circular Permutation: &emsp;$(n-1)!$; &ensp;
L1790	Circular Permutation without Repetition: &emsp;
                    $Q^n_k=\dfrac{n!}{k\cdot(n-k)!}$; &emsp;&emsp;$Q^n_k=\dfrac{P^n_k}{k}$; &ensp;
L1794	Circular Permutation with Repetition: &emsp;
                    $\dfrac{\sum_{r|k}(r\cdot\varphi(r)\cdot{n^{\frac{k}{r}}})}{k}$; &ensp;
L1809	Normal Distribution
L1820	Statistics
L1829	Linear Regression: &ensp;
                    $\displaystyle{\equd{
                    m=\dfrac{n\sum{xy}-\sum{x}\sum{xy}}{n\sum{x^2}-(\sum{x})^2}
                    =\dfrac{\sum{xy-n\overline{x}\overline{y}}}{\sum{x^2-n\overline{x}^2}}}
                    {b=\overline{y}-m\overline{x}}
                    }$ , &ensp;
                    $y=mx+b$;
L1836	Strength of linear relationship in Linear Regression: &ensp;
                    $ \displaystyle{r = \dfrac{
                    \sum{(x_i-\overline{x})(y_i-\overline{y})}}{
                    \sqrt{\sum{(x_i-\overline{x})^2}\sum{(y_i-\overline{y})^2}}
                    } \in (0,1]}$ ; &ensp;
L1866	<!-- For Easier Editing -->
L1928	"6px solid SaddleBrown"
L1929	"BurlyWood"
L1931	"Consolas"
L1947	<!-- Function Grapher -->
L2045	// encode canvas to bitmap

D:\Coding\Github\Notes\Inertia.html
UTF-8 BOM detected
Line ending: \r\n
L4	List of Moments of Inertia
L7	<!-- graph plotter -->
L9	// math
L22	// cubic solver least-square magic
L25	// graph rendering function
L27	// rotation about x-axis
L28	// rotation about z-axis
L29	// scaling factor
L30	// translation in world coordinate
L31	// translation in screen coordinate
L40	// graphics
L41	// text
L43	// viewport settings
L59	// projection information
L61	// tell where to connect lines when drawing cylinders
L67	// tell where to connect lines when drawing cones
L75	// graphing functions
L110	// recursively fit elliptic arc to piecewise Bezier splines
L157	// graphing
L168	// renderer calling function
L173	// interactive graph, available in debug mode
L208	// debug mode: change MathJax script tag to something else
L229	/* graphs with issues:
             * Solid angle
             * Torus
             * Ellipsoid
             * Cylindrical shell with thickness
             */
L235	/* blank graphs:
             * Toric shell
             * Toric shell with thickness
             */
L256	'Times New Roman'
L320	<!-- Mathjax -->
L325	"alert('Failed to load MathJax')"
L329	<!-- hacking MathJax-->
L337	/*outline-width: 0px;
            outline-style: none;*/
L346	List of moments of inertia
L351	Description
L352	Length / Area / Volume
L353	Centroid /
L353	Center of mass
L354	Inertia tensor
L355	Additional notes
L358	<!-- The correctness of this part is to be determined -->
L360	Mass change
L361	Multiplying the density of a body by
L364	Remain unchanged
L367	Remain unchanged
L373	For the rest of this table, assume the mass of the body remains unchanged after transformation.
L378	Translation
L379	Translating a body by displacement $d$.
L382	Remain unchanged
L394	Bold $\mathbf{I}$ represents the 3×3 identity matrix.
L399	Rotation about origin
L400	Representing rotation using orthogonal matrix $\mathbf{R}$ where the columns of $\mathbf{R}$ are $\vec{i}, \vec{j}, \vec{k}$ after rotation.
L403	Remain unchanged
L415	Scaling
L417	Scaling about origin with factor $s>0$.
L428	Reference rule 0. for mass change.
L433	Reflection about
L434	xOy
L434	plane
L434	Reversing the signs of $z$ components of points in a body.
L437	Remain unchanged
L440	Reflected about
L441	xOy
L441	plane
L443	Remain unchanged
L449	Reflection
L450	Reflection about a plane through the origin with unit normal $\mathbf{n}.$
L453	Remain unchanged
L461	Extrusion from 2D
L462	Extruding a shape on
L463	xOy
L463	plane on both positive and negative directions of
L463	-axis
L463	by length $h$.
                        (the result is a cylinder with height $2h$.)
L469	Remain unchanged
L475	$m$ represents the mass of the body before and after transformation. Reference rule 0. for mass change.
L480	Revolution from 2D
L481	Rotate a shape on
L482	xOz
L482	plane or other planes perpendicular to
L482	xOy
L482	plane about
L482	-axis
L482	to form a ring-liked body. The shape should not intersect the
L486	Surface to volume by connecting with
L487	xOy
L487	plane
L487	Orthogonally connecting each point on a surface to
L488	xOy
L488	plane to form a volume. The surface should be intuitively valid for this transform.
L492	Surface to volume by connecting with the origin
L493	Connecting points on a surface/line to the origin to form a volume/surface. A ray from the origin should intersect the surface/line no more than once.
L496	<!-- This formula is INCORRECT. -->
L506	If a ray from the origin intersects surface twice, volume under the surfaces is counted twice. Thus this formula does not apply for non-simple regions. (ex. toric shell)
L515	Description
L516	Length / Area / Volume
L517	Moment of inertia / Inertia tensor
L518	Graph
L519	Additional notes
L522	<!-- Rod ... Sector -->
L524	Rod
L547	Disk
L568	Ring
L589	Ring with width
L613	Sector
L638	Arc
L664	Truncated circle
L675	<!-- Cylinder ... Torus -->
L677	Cylinder
L701	The height of this cylinder is $2h$.
                        For a cylinder with height $h$, change $4h^2$ in the inertia matrix to $h^2$.
L707	Sphere
L728	Cone
L756	Right-oriented cone
L785	Cone at center of mass
L808	In the graph the cone has $z$ ranged from $-\frac{1}{4}h$ to $\frac{3}{4}h$.
L809	Reflection on
L810	xOy
L810	plane does not change its inertia.
L814	Truncated cone
L854	Solid angle
L883	Semi-sphere is a special case with $c=0$.
L888	Truncated sphere
L893	Torus
L921	Not implemented torus projection.
L925	<!-- Ellipse ... Truncated elliptical cone -->
L927	Planar ellipse
L950	Planar elliptical ring
L955	Elliptical cylinder
L982	Change $4h^2$ to $h^2$ for a cylinder with height $h$.
L987	Ellipsoid
L1010	Not implemented ellipsoid projection.
L1014	Elliptical cone
L1044	Truncated elliptical cone
L1079	<!-- Cylindrical shell ... Toric shell -->
L1081	Cylindrical shell
L1106	Without base
L1111	Spherical shell
L1132	Conical shell
L1155	Without base
L1162	Conical shell at center of mass
L1185	In the graph the cone has $z$ ranged from $-\frac{1}{3}h$ to $\frac{2}{3}h$.
L1186	Reflection on
L1187	xOy
L1187	plane does not change its inertia.
L1191	Truncated spherical shell
L1219	Semi-sphere is a special case with $c=0$.
L1224	Truncated conical shell
L1258	Without bases
L1264	Elliptical cylindrical shell
L1269	Ellipsoidal shell
L1274	Elliptical conical shell
L1279	Truncated elliptical conical shell
L1284	Toric shell
L1297	<!-- Cylindrical shell with thickness ... Toric shell with thickness -->
L1299	Cylindrical shell with thickness
L1332	Change $4h^2$ in the inertia matrix to $h^2$ for a cylinder with height $h$.
L1337	Spherical shell with thickness
L1363	Truncated conical shell with thickness
L1378	Toric shell with thickness
L1398	Description
L1399	Length / Area / Volume
L1400	Centroid /
L1400	Center of mass
L1401	Inertia tensor
L1404	<!-- Segment ... Tetrahedron with one vertex at origin-->
L1406	Segment defined by endpoints
L1420	Triangle defined by the origin and vectors $\vec{a}$, $\vec{b}$
L1434	Triangle defined by vertices
L1449	Parallelogram defined by point $p$ and vectors
L1464	Tetrahedron defined by the origin and vectors
L1484	Description
L1485	Length / Area / Volume
L1486	Moment of inertia / Inertia tensor
L1487	Graph
L1488	Additional notes
L1491	<!-- Square ... Border of regular polygon -->
L1493	Square
L1504	Rectangle
L1515	Border of rectangle
L1526	Equilateral triangle
L1537	Regular polygon
L1548	Border of regular polygon
L1559	<!-- Cube ... Cube shell with thickness-->
L1561	Cube
L1572	Box (cuboid)
L1583	Cube shell
L1594	Box shell
L1605	Cube shell with thickness
L1617	Regular tetrahedron
L1622	Regular octahedron
L1627	Regular dodecahedron
L1632	Regular icosahedron
L1637	Regular tetrahedron shell
L1642	Regular octahedron shell
L1647	Regular dodecahedron shell
L1652	Regular icosahedron shell
L1657	Regular polygonal cylinder
L1662	Regular polygonal cylindrical face
L1667	Regular polygonal pyramid
L1672	Regular polygonal pyramidal face
L1677	Rounded rectangle
L1682	Rounded box
L1687	2d capsule
L1692	3d capsule
L1697	Rounded cylinder
L1702	Rounded cone
L1707	Rounded truncated torus
L1712	Link
L1717	Rounded rectangle shell
L1722	Rounded box shell
L1727	2d capsule shell
L1732	3d capsule shell
L1737	Rounded cylinder shell
L1742	Rounded cone shell
L1747	Rounded truncated torus shell
L1752	Link shell
L1757	Area from origin to quadratic parametric curve
L1762	Area from origin to cubic parametric curve
L1767	Volume from origin to bilinear surface
L1772	Volume from origin to biquadratic surface
L1777	Volume from origin to bicubic surface
L1782	Quadratic parametric curve
L1787	Bilinear surface
L1792	More ideas: intersections, helix, bolt, spiral, snail...
L1800	// add index number
L1801	// note that some cells are hidden
L1815	References
L1816	Moment of inertia - Wikipedia
L1817	Parallel axis theorem - Wikipedia
L1818	Perpendicular axis theorem - Wikipedia
L1819	List of moments of inertia - Wikipedia
L1822	Additional notes
L1823	Most integrations are done manually and checked numerically.
L1824	Formulas are rendered with
L1825	MathJax
L1825	. A script has been used to generate latex.
                    Graphs are generated with Javascript.
L1828	Please
L1828	check my math and English

D:\Coding\Github\Notes\README.md
Line ending: \r\n

D:\Coding\Github\Notes\Substitution.html
UTF-8 BOM detected
Line ending: \r\n
L4	Multidimensional Integral Substitutions
L10	"alert('Failed to load MathJax')"
L26	'Times New Roman'
L62	/* use to make table column widths straight */
L68	<!-- hacking MathJax -->
L88	2-dimensional integral substitutions
L92	Description
L93	Transform
L94	Inverse transform
L95	Other properties /
L95	Additional notes
L96	Jacobian
L97	Commonly apply to
L100	Polar
L102	$\rho$: distance to origin
L103	$\theta$: polar angle
L122	Circular integral regions
L123	Planar regions described by implicit algebraic equations
L128	Generalized polar
L129	$a,b$: scaling on
L130	and
L130	-axis
L147	Elliptical integral regions
L153	Isosceles right triangle formed by axis
L154	$u$: distance to origin (Manhattan)
L155	$v$: linear interpolation coefficient from
L156	-axis
L174	Region in the first quadrant defined by $x+y\le a$
L179	Triangle defined by origin and two vectors $\vec{a}, \vec{b}$
L195	Triangular integral regions
L196	Green formula for regions inside polygons
L201	Matrix
L214	Parallelogram / Triangle
L224	3-dimensional integral substitutions
L228	Description
L229	Transform
L230	Inverse transform
L231	Other properties /
L231	Additional notes
L232	Jacobian
L233	Commonly apply to
L236	Cylindrical
L238	$\rho$: distance to origin
L239	$\theta$: polar angle
L240	$h$: height
L261	Integral volumes with circular bases
L266	Generalized cylindrical
L267	$a,b$: scaling on
L268	and
L268	-axis
L287	Integral volumes with elliptical bases
L292	Spherical (standard)
L294	$\rho$: distance to origin
L295	$\theta$: longitude
L296	$\varphi$: angle to vertical axis
L318	Spherical (
L319	) and conical (
L319	) volumes
L319	Volumes defined by implicit algebraic equations
L324	Spherical (latitude)
L326	$\rho$: distance to origin
L327	$\theta, \varphi$: longitude and latitude
L349	Spheres
L354	Generalized spherical
L355	$a,b,c$: scaling on
L356	, and
L356	-axis
L376	Ellipsoids
L381	Conical
L382	$\rho h$: radius of circle at $z=h$
L396	$0\le\rho\le\frac{r}{h_1}$ for integral in a cone with height $h_1$ and base radius $r$
L402	Cones
L407	Generalized conical
L408	$a,b,c$ are scaling factors on
L409	x, y, z
L409	axis
L428	Elliptic cones with base radius $a,b$ and height $c$
L433	Toric
L435	$u$: longitude
L436	$v$: latitude
L437	$\rho$: radius of small circle
L438	$R$: radius of large circle
L460	Toruses
L465	Tetrahedron formed by coordinate planes and a plane with $\vec{n}=(1,1,1)$
L468	xOy
L468	-axis
L469	xOz
L469	yOz
L470	x + y + z
L490	Volume in the first octant defined by $x+y+z\le a$
L495	Tetrahedron defined by origin and three vectors $\vec{a}, \vec{b}, \vec{c}$
L503	Transform $\vec{p}$ using $[\vec{a},\vec{b},\vec{c}]^{-1}$ and apply the formula in the above cell
L514	Gauss divergence theorem for integrals inside polyhedrons
L524	3-dimensional areal elements
L530	Description
L531	Parametric equation
L532	Directional derivatives
L533	Normal vector
L534	Areal element
L537	Triangle defined by point $p$ and vectors $\vec{a},\vec{b}$
L557	Parallelogram defined by point $p$ and vectors $\vec{a},\vec{b}$
L576	Cylinder with base
L577	radius $r$
L597	Standard sphere with radius&nbsp;$r$
L618	Sphere with radius $r$ parametrized on latitude
L639	Cone with $k$ equals to the tangent of one half of the opening angle
L659	Cone with base radius $r$ and height $h$
L679	Torus with major radius $R$ and minor radius $r$
L700	Elliptic cylinder with scaling factor $a,b$ on
L701	x, y
L701	axis
L720	Ellipsoid with radius $a,b,c$ on
L721	x, y, z
L721	axis
L744	Elliptic cone with radius $a,b$ on cross section with $z=1$
L770	Bilinear surface
L786	Biquadratic surface
L799	Bicubic surface

D:\Coding\Github\Notes\UnicodeTable.txt
Ignored

D:\Coding\Github\Notes\Equations Tools\csh.cpp
Line ending: \r\n
L1	// Processing equation htmls generated by browser after Mathjax finished rendering
L2	// The result file can be quite large but loads faster
L16	"Error: incorrect number of parameters. (%d)\n"
L20	// read file (max 16MB)
L31	// start timer
L34	// erase html <script> element and comments
L51	// replace date substring
L65	// write file
L73	// skip line breaks and consecutive spaces
L81	// sometimes hurts normal text

D:\Coding\Github\Notes\Equations Tools\csh.js
Line ending: \r\n
L1	// compressing loaded html notes
L2	// intended to heavily compress Mathjax
L4	// run as Chrome snippet
L5	// make sure MathJax are fully-loaded as HTML/CSS
L6	// right click - Math Settings - Math Renderer - HTML-CSS
L8	// agressive compression, sometimes hurts normal html
L9	// MathJax nobr paddings may be removed
L11	// TODO: compress style attributes more
L16	// test if an element should be discarded by tagname
L23	// test if an element should be discarded by style
L31	// test if an element should be discarded by attributes
L38	// compress text node type value
L41	// this sometimes hurts (saves 0.3%)
L50	// compress attribute strings
L58	// removing all whitespaces hurts (ex. 2px solid => 2pxsolid)
L64	// compress css content
L72	// remove css that override classes
L75	// remove comments
L85	// get a list of class names from class attribute string
L90	// remove unused class names by MathJax
L91	"MathJax"
L101	// count the occurence of style attributes
L117	// pass html root element (or document.body) to this function
L130	// find style attributes that occupies most html length
L134	// may not be a good comparing function
L140	// use class names with no more than 2 letters to avoid collision
L141	// some style attributes are like to come together. maybe...
L158	// recursively go through html elements
L169	// discard unwanted elements
L178	// "style" tagname, attributes are discarded
L181	// be careful not to get normal css removed
L189	// recursion
L196	// get element attributes
L202	// compress class attribute
L221	// convert most occured styles to classes
L230	// add attributes back
L242	"MathJax"
L252	// add a stylesheet
L258	// override MathJax frame CSS
L266	// "<!DOCTYPE html>" affects page appearance??

D:\Coding\Github\Notes\Equations Tools\latex_desmos.js
Line ending: \r\n
L1	// extracting latex expressions from Desmos online calculator
L3	// clear all expressions
L12	// convert latex expressions to fit personal preference (might hurt)
L13	// set d0 to 1 for not converting \frac
L34	// extract all expressions as a string
L43	// extract first 9 elements as a 3x3 matrix

